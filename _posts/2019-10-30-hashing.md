---
title: "Algorithm, Hashing"
date: 2019-10-30 15:30:28 -0400
categories: Algorithm
tags : [Algorithm, Hashing]
---
- 해쉬테이블은 하나의 배열이라고 생각하자
- ex
  - ##### h(k) = k % m ,
  즉 key를 하나의 자연수로 해석할 후 테이블의 크기 m으로 나눈 나머지
  - 항상 0 ~ m-1 사이의 정수가 된다
  - 단점 : 충돌발생

#### 충돌
- h(k1) = h(k2)인 상황
- 해결 방법
  - <b>chaining, open addressing</b>

#### chaining
- 동일한 장소에 해슁된 모든 키들을 하나의 연결리스트로 저장
1. 키의 삽입
    - 키 k를 리스트 T[h(k)]의 맨 앞에 삽입 : 시간복잡도 O(1)
    - 중복된 키가 들어올 수 있고 <b>중복 저장이 허용되지 않는다면</b> 삽입시 검색해야함. 따라서 시간복잡도는 <b>리스트의 길이에 비례</b>
2. 키의 검색
    - 리스트 T[h(k)]에서 <b>순차검색</b>
    - 시간복잡도 : 키가 저장된 <b>리스트의 길이에 비례</b>
3. 키의 삭제
    - 리스트 T[h(k)]로 부터 키를 검색 후 삭제
    - 키 검색 후 O(1)시간에 삭제 가능

- 최악의 경우 : 모든 키가 하나의 슬롯으로 해슁되는 경우
- 평균시간복잡도는 키들이 여러 슬롯에 얼마나 잘 분배되느냐에 의해 결정
---
#### Linear probing
![linear probing](https://user-images.githubusercontent.com/55946791/67824300-44428b80-fb09-11e9-87ac-2d925f568980.JPG)
- h(k), h(k)+1, h(k)+2... 순서로 검사하여 처음으로 빈 슬롯에 저장
- 테이블의 끝에 도달하면 다시 처음으로 circular하게 돌아감
- 키삭제시 문제 발생 !
  - A2,B2,C2가 모두 동일한 해쉬함수를 가져서 linear probing으로 충돌 해결
  - B2를 삭제하고 C2를 검색하면, 배열2 자리를 검색하고 A2로 충돌되어있는것을 확인
  - +1하여 배열3자리를 보는데 값이 비어있으니, C2는 없다고 판단된다
  ![linear probing문제](https://user-images.githubusercontent.com/55946791/67825157-c2a02d00-fb0b-11e9-9494-71b042a63179.JPG)


#### 단점
- cluster가 점점 커지는 경향이 생긴다
- 클러스터길이 만큼 검색해야하므로 클러스터가 길어지면 안된다
- 해결
  - <b>Quadratic probing</b> : 충돌 발생시 h(k), h(k)+1의 2승, h(k)+2의 2승...순서로 시도
  ![quadratic probing](https://user-images.githubusercontent.com/55946791/67824642-57099000-fb0a-11e9-83b5-b74fa13f1d35.JPG)

   - <b>Double hashing</b> : 서로 다른 두 해쉬 함수 h1과 h2를 이용
  - h(k,i) = (h1(k) + i*h2(k)) mod m
  ![Double hashing](https://user-images.githubusercontent.com/55946791/67824886-f4fd5a80-fb0a-11e9-86b6-aef38eaee9f9.JPG)
- 차이점 :  Quadratic probing는 충돌 발생 후 다음 자리를 찾을때 더하는 수가 점점 증가 / Double hashing은 충돌 발생 후 다음 자리 찾을때 더하는 수가 일정

---
### 해쉬 함수
#### division 기법
- h(k) = k mod m
- 장점 : 한번의 mod연산으로 계산해서 빠르다
- 단점 : 해쉬 함수값이 키값의 특정 부분에 의해서 결정되는 경우가 있다

---
### JAVA 예제
##### put() : 값 넣기
```java
HashMap<Integer, String> map = new HashMap<Integer, String>();
map.put(1, "아메리카노");
map.put(2, "카푸치노");
map.put(3, "카페라떼");
// {1=아메리카노, 2=카푸치노, 3=카페라떼}
System.out.println(map)
```

##### get(key) : key로 값가져오기
```java
// key 로 값을 가져오는 방법
String val = map.get(3);
// key값이 3인 데이터 :카페라떼
System.out.println("key값이 3인 데이터 :"+val);
```

##### 모든 데이터 가져오기
 keySet() : 모든 key값들의 모음
- Iterator객체 : 모든 컬렉션클래의 데이터를 읽을때 사용
```java
// Iterator : 모든 컬렉션클래스에 데이터를 읽을때 사용
// keySet() : key값들의 모음 , [1, 2, 3]
Iterator<Integer> keySetIterator = map.keySet().iterator();
while(keySetIterator.hasNext()) {
  int key = keySetIterator.next();
  System.out.println("key : "+key+", value : "+map.get(key));
}
//key : 1, value : 아메리카노
//key : 2, value : 카푸치노
//key : 3, value : 카페라떼
```

##### 삭제
- remove(key) : 특정값 삭제 후 데이터 반환
- clear() : 모든 객체 지우기
```java
int key = 3;
Object value = map.remove(key);
System.out.println("key 3 값 삭제 후 리턴받은 값 : "+value);
//key 3 값 삭제 후 리턴받은 값 : 카페라떼
```



---

## Reference
<https://www.inflearn.com/course/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B0%95%EC%A2%8C/lecture/4103><br>
<https://mainia.tistory.com/2237>



---
