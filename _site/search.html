<!DOCTYPE html>
<html class="no-js">
  <head>
	<meta charset="utf-8">
	<title>Search | devYurim</title>
	<meta name="description" content="developer blog">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- CSS -->
	<link rel="stylesheet" href="/assets/css/main.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

	<!-- Canonical -->
	<link rel="canonical" href="/search.html">

	<!-- RSS -->
	<link rel="alternate" type="application/atom+xml" title="devYurim" href="/feed.xml" />

	<!-- Font Awesome -->
	<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

	<!-- Google Fonts -->
	
	<link href="https://fonts.googleapis.com/css?family=Nanum+Gothic:400,700" rel="stylesheet">
	

	<!-- KaTeX -->
	
	<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.css">
	<script src="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.js"></script>
	

	<!-- Google Analytics -->
	
	<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-111748939-1', 'auto');
	ga('send', 'pageview');
	</script>
	
</head>

  <header class="site-header">
	<div class="branding">
		
		<a href="/">
			<img class="avatar" src="/assets/img/blogmark.png" alt=""/>
		</a>
		
		<h1 class="site-title">
			<a href="/">devYurim</a>
		</h1>
		<nav class="site-nav">
				<ul>
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
							<li>
								<a class="page-link" href="/about/">
									About
								</a>
							</li>
						
					
						
					
						
					
						
					
						
					
						
					
						
							<li>
								<a class="page-link" href="/tags.html">
									tags
								</a>
							</li>
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					

					<!-- Search bar -->
					
					<li>
					<form action="/search.html" method="get">
						<input type="text" id="search-box" name="query" placeholder="Search" class="">
						<button type="submit" class="">
							<i class="fa fa-fw fa-search"></i>
						</button>
					</form>
					</li>
					
				</ul>
		</nav>
	</div>

	<div class="site-category">
			<ul class='cat1'>
				<li><a href="/">Home</a></li>
				<li><a href="/">Python</a>
					<ul>
							<li><a href="/Python/Crawler">Crawler</a></li>
							<li><a href="/Python/Django">Django</a></li>
							<li><a href="/Python/Tensorflow">Tensorflow</a></li>
					</ul>
				</li>

				<li><a href="/">Data Science</a>
					<ul>
						<li><a href="/DS/Statistics">Statistics</a></li>
						<li><a href="/DS/R">R programming</a></li>
						<li><a href="/DS/ML">Machine Learning</a></li>
						<li><a href="/DS/ADsP">ADsP</a></li>
					</ul>
				</li>
				<li><a href="/">Data Base</a>
					<ul>
						<li><a href="/DB/MYSQL">MYSQL</a></li>
					</ul>
				</li>

				<li><a href="/">Development Enviroment</a>
					<ul>
						  <li><a href="/DE/Github Blog">Github Blog</a></li>
						  <li><a href="/DE/Git">Git</a></li>
						  <li><a href="/DE/Docker">Docker</a></li>
						  <li><a href="/DE/Ubuntu">Ubuntu</a></li>
						  <li><a href="/DE/Java">Java</a></li>
					</ul>
				</li>

				<li><a href="/">Android</a>
					<ul>
						<li><a href="/Android/Android">Android</a></li>
					</ul>
				</li>

			</ul>
		</div>

</header>

  <body>
    <div class="content">
      <article >
  <header style="background-image: url('/')">
    <h1 class="title">Search</h1>
      
  </header>
  <section class="post-content"><div class="search">
    <div id="search-results"></div>
    <p id="not-found" style="display: none">
        No results found.
    </p>
</div>


<script>
  window.store = {
    
      "data-20science-adsp-2018-08-21-adsp-9-html": {
        "title": "(ADsP 2과목) 4-2. 데이터 분석 기획의 이해 - 분석 방법론",
        "tags": "ADsP-Part2",
        "date": "August 21, 2018",
        "author": "",
        "category": "",
        "content": "   1. KDD(Knowledge Discovery in Database) 분석 방법론   1996년 Fayyad가 체계적으로 정리한 데이터 마이닝 프로세스  데이터 마이닝, 기계학습, 인공지능, 패턴인식, 데이터 시각화 등에서 응용될 수 있는 구조를 가짐  분석 절차          분석 대상의 비즈니스 도메인에 대한 이해와 프로젝트 목표를 정확하게 설정      데이터셋 선택(Selection)      데이터 전처리(Preprocessing) : 잡음(Noise), 이상값(Outlier), 결측치(Missing value) 제거      데이터 변환(Transformation) : 변수 선택, 차원 축소 등      데이터 마이닝(Data Mining) : 분석 목적에 맞는 데이터 마이닝 기법 알고리즘 선택, 데이터 패턴 찾기, 데이터 분류, 예측 작업 시행      데이터 마이닝 결과 평가(Interpretation/Evaluation) : 분석 결과에 대한 해석, 평가, 활용         2. CRISP-DM(Cross Industry Standard Process for Data Mining) 분석 방법론  1996년 유럽 연합의 ESPRIT 프로젝트에서 시작  계층적 프로세스 모델로 4개 레벨로 구성  분석 절차          업무 이해(Business Understanding) : 비즈니스 관점 프로젝트의 목적과 요구사항 이해, 초기 프로젝트 계획 수립      데이터 이해(Data Understanding) : 분석을 위한 데이터 수집, 데이터 속성 이해, 데이터 기술 분석, 데이터 탐색, 데이터 품질 확인      데이터 준비(Data Preparation) : 분석 기법에 적합한 데이터셋 선택, 데이터 정제, 통합, 포맷팅      모델링(Modeling) : 모델링 기법과 알고리즘 선택, 파라미터 최적화, 과적합(Overfitting) 발견      평가(Evaluation) : 모델이 프로젝트의 목적에 부합하는지 평가, 분석 결과 평가, 모델링 과정 평가, 모델 적용성 평가      전개(Deployment) : 완성된 모델을 실제 업무에 적용하기 위한 계획 수립 및 유지 보수 계획 마련, 프로젝트 종료 보고서 작성, 프로젝트 리뷰         3. KDD VS CRISP-DM             KDD      CRISP-DM                  분석 대상 비즈니스 이해      업무 이해(Business Understanding)              데이터셋 선택(Selection)      데이터 이해(Data Understanding)              데이터 전처리(Preprocessing)                     데이터 변환(Transformation)      데이터 준비(Data Preparation)              데이터 마이닝(Data Mining)      모델링(Modeling)              데이터 마이닝 결과 평가(Interpretation/Evaluation)      평가(Evaluation)              데이터 마이닝 활용      전개(Deployment)         4. 빅데이터 분석 방법론   기획 : 계획을 위한 수립 및 진행과정  계획 : 기획을 통해 산출되는 결과   5. 분석 기획(Planning) 1) 비즈니스 이해 및 범위 설정   비즈니스 이해 : 비즈니스 자료 조사  프로젝트 범위 설정 : 프로젝트에 참여하는 관계자들(Stakeholders)의 이해를 일치시키기 위하여 구조화된 프로젝트 범위 정의서인 SOW(Statement of Work) 작성2) 프로젝트 정의 및 계획 수립   데이터 분석 프로젝트 정의 : 프로젝트 목표 및 KPI(핵심 성과 지표), 목표 수준 등을 구체화, 모델 이미지 평가 기준 설정  프로젝트 수행 계획 수립 : 프로젝트 수행 계획서 작성하는 단계, 프로젝트의 목적 및 배경, 기대효과, 수행 방법, 일정 및 추진 조직, WBS 작성(전체업무를 구성 요소를 만든 후 각 요소 평가하고 일정별로 계획하며 완수 할 수 있는 사람에게 할당해주는 역할을 함)3) 프로젝트 위험 계획 수립  데이터 분석 위험 식별, 계획 수립 단계에서 발생 가능한 모든 위험을 식별, 식별된 위험의 우선순위 설정  위험 대응 계획 수립 : 회피(Avoid), 전이(Transfer), 완화(Mitigate), 수용(Accept)로 구분하여 위험 관리 계획서 작성   6. 데이터 준비(Preparing) 1) 필요 데이터 정의   데이터 정의 : 데이터 정의서 작성(메타데이터 정의서, ERD(Entity Relationship Diagram))  데이터 획득 방안 수립2) 데이터 스토어 설계   정형 데이터 스토어 설계 : 관계형데이터베이스(RDBMS) 이용, 데이터 매핑 정의서  비정형 데이터 스토어 설계 : 하둡, NoSQL 이용3) 데이터 수집 및 정합성 점검  데이터 수집 및 저장 : ETL(Extract Transform Laod)로 데이터 수집(ex. 크롤러)  데이터 정합성(무결성) 점검   7. 데이터 분석(Analyzing) 1) 분석용 데이터 준비   비즈니스 룰 확인 : 비즈니스 이해, 도메인 문제점 인식, 프로젝트 정의 등을 통해 프로젝트 목표 정확히 인식  분석용 데이터셋 준비 : 데이터 스토어로부터 분석에 필요한 정형, 비정형 데이터 추출2) 텍스트 분석   어휘/구문 분석(Word Analysis), 감정 분석(Sentimental Analysis), 토픽 분석(Topic Analysis), 오피니언 분석(Opinion Analysis), 소셜 네트워크 분석(SNA)3) 탐색적 분석(EDA)   기초 통계량 산출, 데이터 분포와 변수간의 관계 파악, 데이터 시각화4) 모델링(Modeling)   데이터 분할 : 훈련용 데이터셋과 테스트용 데이터셋으로 분리하여 과적합 방지  데이터 모델링  모델 적용 및 운영 방안 : 모델에 대한 상세한 알고리즘 작성5) 모델 평가 및 검증 : 테스트 데이터셋을 이용하여 모델 검증 작업 실시, 보고서 작성   8. 시스템 구현(Developing)   시스템 분석 및 설계 구현  시스템 테스트 및 운영 : 단위테스트, 통합테스트, 시스템 테스트 실시   9. 평가 및 전개(Deploying)   모델 발전 계획 수립  프로젝트 평가 보고 : 프로젝트의 성과를 정량적, 정성적으로 평가 하고 최종보고서 작성",
        "url": "//data%20science/adsp/2018/08/21/ADsP-9.html"
      }
      ,
    
      "data-20science-adsp-2018-08-21-adsp-8-html": {
        "title": "(ADsP 2과목) 4-1. 데이터 분석 기획의 이해 - 분석 기획 방향성 도출",
        "tags": "ADsP-Part2",
        "date": "August 21, 2018",
        "author": "",
        "category": "",
        "content": "   1. 분석 기획의 특징   분석 기획 : 실제 분석을 수행하기에 앞서 분석을 수행할 과제의 정의 및 의도했던 결과를 도출 할 수 있도록 이를 적절하게 관리 할 수 있는 방안을 사전에 계획하는 작업  분석기획을 하기 위해서는 컴퓨터 사이언스, 수학&amp;통계학 지식, 비즈니스 분석능력에 대한 고른 역량과 시각이 필요하다.  2.분석 주제 유형(4가지 유형을 융합적으로 반복)   최적화(Optimization) : 분석 대상 및 분석 방법을 이해하고 현 문제를 최적화의 형태로 수행  솔루션(Solution) : 분석 과제는 수행되고, 분석 방법을 알지 못하는 경우 솔루션을 찾는 방식으로 분석과제 수행  통찰(Insight) : 분석 대상이 불분명하고, 분석 방법을 알고 있는 경우 인사이트 도출  발견(Discovery) : 분석 대상, 방법을 모른다면 발견을 통하여 분석 대상 자체를 새롭게 도출            분석의 대상(What)분석의 방법(How)      Known      Un-Known                  Known      최적화(Optimization)      통찰(Insight)              Un-Known      솔루션(Solution)      발견(Discovery)        3. 목표 시점별 분석 기획 방안   과제 중심적인 접근 방식 : 당면한 과제를 빠르게 해결  장기적인 마스터 플랜 방식 : 지속적인 분석 내재화  이 둘을 융합적으로 적용하는 것이 바람직 함            당면한 분석 주제의 해결(과제 단위)             지속적 분석 문화 내재화(마스터 플랜 단위)                  Speed &amp; Test      &lt;1차 목표&gt;      Accuracy &amp; Deploy              Quick-Win            Long Term View              Problem Solving            Problem Definition      cf) Quick-win(즉각적인 실행을 통한 성과 도출) : 프로세스 진행과정에서 일반적인 상식과 경험으로 원인이 명백한 경우 불합리한 요소를 개선 단계까지 미루지 않고, 바로 개선함으로써 과제를 단기로 달성하고 추진하는 과정   4. 분석 기획 시 고려 사항   가용한 데이터 : 분석을 위한 데이터 확보가 필수적이다. 데이터 유형에 따라 적용가능한 솔루션 및 분석 방법이 다르기 때문에 데이터 유형에 대한 분석이 선행적으로 이루어져야 한다.  적절한 유스케이스(Proper Use-Case) 탐색 : 유사 분석 시나리오 및 솔루션이 있다면 이를 최대한 활용하는 것이 중요하다.  장애 요소들에 대한 사전 계획 수립이 필요(Low Barrier of Execution) : 정확도를 올리기 위한 비용 사전 고려, 조직의 역량 내재화를 위한 충분하고 계속적인 교육 및 활용 방안 등의 변화관리(Change Management)가 고려되어야 한다.",
        "url": "//data%20science/adsp/2018/08/21/ADsP-8.html"
      }
      ,
    
      "data-20science-adsp-2018-08-21-adsp-7-html": {
        "title": "(ADsP 1과목) 4. 추가 정리 사항",
        "tags": "ADsP-Part1",
        "date": "August 21, 2018",
        "author": "",
        "category": "",
        "content": "   1. 분석의 전형적인 의사결정 오류   로직 오류 : 의도치 않은, 바라지 않은 결과 유발(작동은 됨)  프로세스 오류 : 작동에 문제가 발생한 오류",
        "url": "//data%20science/adsp/2018/08/21/ADsP-7.html"
      }
      ,
    
      "data-20science-adsp-2018-08-20-adsp-6-html": {
        "title": "(ADsP 1과목) 3-1,2,3. 데이터 사이언스와 전략 인사이트 - 전략 인사이트 도출을 위한 필요 역량, 빅데이터 그리고 데이터 사이언스의 미래",
        "tags": "ADsP-Part1",
        "date": "August 20, 2018",
        "author": "",
        "category": "",
        "content": "   1. 전략 인사이트 도출을 위한 필요 역량 1) 데이터 사이언스 의미와 역할  대상 : 정형 또는 비정형을 막론하고 인터넷, 휴대전화, 감시용 카메라 등에서 생성되는 숫자와 문자, 영상 정보 등 다양한 유형의 데이터를 대상으로 함  기존의 통계학과 다른점은 총제적 접근법을 사용한다는 점이다.  전략적 통찰을 추구하고, 비즈니스 핵심 이슈에 답을 하고, 사업의 성과를 견인해 나갈수 있다.2) 데이터 사이언스의 3대 구성요소  IT(Data Management)  Analytics(분석적 영역)  비즈니스 분석(비즈니스 컨설팅)3) 데이터 사이언티스트의 역량  데이터 사이언티스트의 중요한 특징 : 강력한 호기심(Intensive curiosity)  호기심 : 문제의 이면을 파고들고, 질문들을 찾고, 검증 가능한 가설을 세우는 능력  Hard skill : 빅데이터에 대한 이론적 지식, 분석 기술에 대한 숙련  Soft skill : 통찰력 있는 분석(창의적 사고, 호기심, 논리적 비판), 설득력 있는 전달(스토리 텔링, Visualization), 다분야 간 협력(Communication)4) 데이터 사이언스 : 과학과 인문의 교차로  전문가들은 데이터 사이언티스트에게 스토리 텔링, 커뮤니케이션, 창의력, 열정, 직관력, 비판적 시각, 글쓰기 능력, 대화 능력(인문학의 주요 주제들)등이 필요하다고 강조하고 있다.5) 데이터 사이언티스트에게 요구되는 인문학적 사고의 특성과 역할                   과거      현재      미래                  Information      무슨 일이 일어났는가?리포팅      무슨일이 일어나고 있는가?경고      무슨일이 일어날 것인가?추출              Insight      어떻게, 왜 일어났는가?모델링      차선 행동은 무엇인가?권고      최악, 최선의 상황은?예측, 최적화      6) 인간을 바라보는 유형별 세가지 관점  타고난 성향의 관점 : 인간은 변하지 않는 존재로 상정  행동적 관점 : 한 사람의 행동을 지속적으로 관찰해 그 행동을 보고 사람을 판단하는 것이 더 정확하다는 관점  상황적 관점 : 특정 행동을 거듭하는 사람은 그 행동을 앞으로도 반복할 확률이 높다는 관점   2. 빅데이터 그리고 데이터 사이언스의 미래   가치 패러다임의 변화          디지털화(Digitalization) : 아날로그의 세상을 어떻게 효과적으로 디지털화 하는가      연결(Connection) : 디지털화 된 정보와 대상들이 서로 연결되어, 이 연결이 얼마나 효과적이고 효율적으로 제공해 주느냐가 성패를 가름, 사물인터넷의 성숙과 함께 앞으로는 연결이 더 증가하고 극도로 복잡해 질 것이다.      에이전시(Agency) : 복잡한 연결을 얼마나 효과적이고 믿을 만하게 관리해 주는가        훌륭한 데이터 사이언티스트는 인문학자들처럼 모델의 능력에 대해 항상 의구심을 가지고, 가정들과 현실의 불일치에 대해 끊임없이 고찰하고, 분석모델이 예측할 수 없는 위험을 살피기 위해 현실세계를 쳐다봐야 한다.",
        "url": "//data%20science/adsp/2018/08/20/ADsP-6.html"
      }
      ,
    
      "data-20science-adsp-2018-08-20-adsp-5-html": {
        "title": "(ADsP 1과목) 2-2,3,4,5. 데이터의 가치와 미래 - 빅데이터의 가치와 영향, 비즈니스 모델, 위기요인과 통제 방안, 미래의 빅데이터",
        "tags": "ADsP-Part1",
        "date": "August 20, 2018",
        "author": "",
        "category": "",
        "content": "   1. 빅데이터의 가치   빅데이터의 가치 산정이 어려운 이유          데이터의 활용 방식: 재사용이나 재조합, 다목적용 데이터 개발 등이 일반화되면서 특정 데이터를 언제, 어디서, 누가 활용했는지 알 수 없다.      새로운 가치 창출: 빅데이터 시대에는 기존에 없던 가치를 창출함에 따라 그 가치를 측정하기 어렵다.      분석기술의 발달: 지금은 가치 없는 데이터도 새로운 분석 기법의 등장으로 거대한 가치를 만들어내는 재료가 될 가능성이 있다.         2. 빅데이터의 영향(생활 전반의 스마트 화)  기업 : 혁신, 경쟁력 제고, 생산성 향상  정부 : 환경탐색, 상황분석, 미래대응  개인 : 목적에 따라 활용   3. 빅데이터 활용 테크닉             종류      설명                  연관 규칙 학습(Association rule learning)      어떤 변수간에 주목할만한 상관관계가 있는지 찾아내는 방법              유형분석(Classification tree analysis)      사건이 속하게 될 범주를 찾아내는 일(어떤 특성을 가진 집단에 속하는가?)              유전알고리즘(Genetic algorithm)      최적화가 필요한 문제의 해결책을 자연선택, 돌연변이 등과 같은 메커니즘을 통해 선택              기계학습(Machine learning)      훈련 데이터로부터 학습한 알려진 특성을 활용해 예측하는 일              회귀분석(Regression analysis)      독립변수와 종속변수의 변화를 파악하여 두 변수의 관계를 파악              감정분석(Sentiment analysis)      특정 주제에 대해 말하거나 글을 쓴 사람의 감정 분석              소셜 네트워크 분석(Social network analysis)=사회관계망분석(SNA)      오피니언 리더영향력이 있는 사람을 찾아낼 수 있으면 고객들 간 소셜관계를 파악할 수 있다.        4. 위기요인 및 통제 방안   사생활 침해          위기 요인 : 특정 데이터가 본래 목적 외에 가공 처리되어 2차, 3차 목적으로 활용될 가능성이 증가      통제 방안 : 동의에서 책임으로, 개인정보 사용자에게 책임을 지게 한다.        책임 원칙의 훼손          위기요인 : 분석 대상이 되는 사람들은 예측 알고리즘의 희생양이 될 가능성이 증가한다. 잠재적 위험사항에 대해서도 책임을 추궁하는 사회로 변질될 가능성이 높아 민주주의 사회 원칙을 훼손할 수 있다.      통제 방안 : 기존의 책임원칙 강화        데이터의 오용          위기 요인 : 주어진 데이터에 잘못된 인사이트를 얻어 비즈니스에 직접 손실을 불러 올 수 있다.      통제 방안 : 데이터 알고리즘에 대한 접근권 허용 및 객관적 인증 방안을 도입하는 필요성 제기         5. 빅데이터 활용 3요소   데이터 : 모든것을 데이터 화  기술 : 빅데이터 분석 알고리즘의 진화 가속  인력 : 데이터 사이언티스트와 알고리즈미스트의 역할이 중요해 질 것으로 전망됨.",
        "url": "//data%20science/adsp/2018/08/20/ADsP-5.html"
      }
      ,
    
      "data-20science-adsp-2018-08-20-adsp-4-html": {
        "title": "(ADsP 1과목) 2-1. 데이터의 가치와 미래 - 빅데이터의 이해",
        "tags": "ADsP-Part1",
        "date": "August 20, 2018",
        "author": "",
        "category": "",
        "content": "   1. 빅데이터의 정의   데이터 크기 관점 : 저장, 관리 분석할 수 있는 범위를 초과하는 규모의 데이터  데이터 분석 관점 : 다양한 종류의 대규모 데이터로부터 저렴한 비용으로 가치를 추출하고 데이터의 초고속 수집, 발굴, 분석을 지원하도록 고안된 차세대 기술 및 아키텍쳐  데이터 가치 관점 : 대용량 데이터를 활용해 작은 데이터에서는 얻을 수 없었던 새로운 통찰이나 가치를 추출해내는 것  3V(Volume, Variety, Velocity)            종류      주요 솔루션                  데이터의 크기(Volume)      생성되는 모든 데이터를 수집              데이터의 다양성(Variety)      정형화된 데이터를 넘어 텍스트, 오디오, 비디오 등 모든 유형의 데이터를 분석 대상으로 함              데이터의 속도(Velocity)      사용자가 원하는 시간 내에 데이터 분석결과를 제공하는 것데이터의 업데이터되는 속도가 매우 빨라지는 것         2. 빅데이터가 만들어내는 본질적인 변화   사전처리 -&gt; 사후처리: 정해진 특정한 정보만 수집하는 것이 아닌 가능한 많은 데이터를 모으고 그 데이터를 다양한 방식으로 조합해 숨은 정보를 찾아낸다.  표본조사 -&gt; 전수조사: 데이터 수집비용이 더는 문제가 되지 않고 클라우드 컴퓨팅 기술의 발전으로 데이터 처리 비용이 급격하게 감소하고 있다. 전수조사의 장점은 표본조사가 주지 못하는 패턴이나 정보를 제공해 준다.  질 -&gt; 양: 데이터의 수가 증가함에 따라 사소한 몇개의 오류가 대세에 영향을 주지 못한다.  인과관계 -&gt; 상관관계: 인과관계 분석은 데이터를 얻는데 드는 비용이 매우 비싼 모델이다. 비즈니스 상황에서는 상관관계 분석으로 충분하다.   3. 데이터의 크기를 나타내는 단위             단위      크기                  1테라바이트(Terabyte)      1024 기가바이트(Gigabyte)              1페타바이트(Petabyte)      1024 테라바이트(Terabyte)              1엑사바이트(Exabyte)      1024 페타바이트(Petabyte)              1제타바이트(Zettabyte)      1024 엑사바이트(Exabyte)      ",
        "url": "//data%20science/adsp/2018/08/20/ADsP-4.html"
      }
      ,
    
      "data-20science-adsp-2018-08-20-adsp-3-html": {
        "title": "(ADsP 1과목) 1-3. 데이터의 이해 - 데이터베이스의 활용",
        "tags": "ADsP-Part1",
        "date": "August 20, 2018",
        "author": "",
        "category": "",
        "content": "   1. 기업 내부 데이터베이스             구분      주요 특징                  1980년대기업내부데이터베이스      1. OLTP(On-line Transaction Processing, 온라인 거래처리) : 주 컴퓨터와 통신회선으로 접속되어 있는 복수의 사용자 단말에서 발생한 트랜잭션을 주 컴퓨터에서 처리하여 그 결과를 즉석에서 사용자에게 되돌려 보내주는 처리 형태  : 데이터는 진행중인 비즈니스 프로세스 : 여러 과정이 하나의 단위 프로세스로 실행되도록 하는 프로세스  : 비즈니스 작업을 제어 및 실행 2. OLAP(On-line Analytical Processing, 온라인 분석처리) : 다차원으로 이루어진 데이터로부터 통계적인 요약 정보를 제공할 수 있는 기술 : 데이터는 모든 유형의 비즈니스 활동을 다차원적으로 보여줌  : 의사결정 지원, 계획 및 문제 해결을 도움              2000년대기업내부데이터베이스      1. CRM(Customer Relationship Management, 고객 관계 관리)  : 선별된 고객으로부터 수익을 창출하고 장기적인 고객관계를 가능하게 함으로써 보다 높은 이익을 창출 할 수 있는 솔루션  2. SCM(Supply Chain Management, 공급망 관리)  : 제조, 물류, 유통업체 등 유통공급망에 참여하는 모든 업체들이 협력을 바탕으로 정보기술(Information Technology)을 활용, 재고를 최적화하기 위한 솔루션  : 유통, 판매 및 고객데이터가 CRM과 연동되므로 CRM과 SCM은 상호밀접한 관련을 가진다.         2. 분야별 기업 내부 데이터베이스             분야      주요 솔루션                  제조 부문      1. DW(Data Warehouse) : 정보 검색을 목적으로 구축된 데이터베이스 2.ERP(Enterprise Resource Planning, 전사적 자원관리) : 제조업을 포함한 다양한 비즈니스 분야에서 생산, 구매, 재고, 주문, 공급자와의 거래, 고객서비스 제공 등 주요 프로세스 관리를 돕는 여러 모듈로 구성된 통합 어플리케이션 소프트웨어 패키지 3. BI(Business Intelligence) : 기업의 DW(Data Warehouse)에 저장된 데이터에 접근해 경영 의사결정에 필요한 정보를 획득하고 이를 경영 활동에 활용하는 것4. CRM(Customer Relationship Management, 고객관계관리) : 선별된 고객으로부터 수익을 창출하고 장기적인 고객관계를 가능케 함으로써 보다 높은 이익을 창출할 수 있는 솔루션              금융 부분      1. EAI(Enterprise Architecture Integration, 기업 어플리케이션 통합) : 기업 내의 ERP(전사적 자원관리), CRM(고객관계관리), SCM(공급망계획) 시스템이나 인트라넷 등의 시스템간에 상호 연동이 가능하도록 통합하는 솔루션2. EDW(Enterprise Data Warehouse) : 기존 DW를 전사적으로 확장한 모델인 동시에 BRP와 CRM, BSC 같은 다양한 분석 어플리케이션을 위한 원천이 됨. : 기업 리소스의 유기적 통합, 다원화된 관리 체계 정비, 데이터의 중복 방지 등을 위해 시스템을 재설계 하는 것3. 블록체인(Blockchain) : 데이터 분산 처리 기술 : 네트워크에 참여하는 모든 사용자의 모든 거래내역 등의 데이터를 분산, 저장하는 기술 : 블록들을 체인 형태로 묶는 형태5. ERP, e-CRM 등 이용              유통 부분      1. KMS(Knowledge Management System, 지식 관리 시스템) : 조직 내의 지식을 체계적으로 관리하는 시스템  : 지적 재산이 매우 중요해짐에 따라 기업을 관리하는 시스템이 등장2. RFID(Radio Frequency, 무선 주파수) 리더를 이용한 정보 인식 : 대상(물건, 사람 등)을 식별할 수 있는 기술3. CRM, SCM 등 이용         3. 분야별 사회기반 구조로서의 데이터베이스   인터넷의 보편화로 인해 일반 국민들도 가정에서 손쉽게 생활에 필요한 정보를 습득할 수 있게 되었고, 이로 인해 데이터베이스는 사회 전반의 기간재로서 자리매김하게 되었다.  EDI(Electronic Data Interchange, 전자 문서 교환) : 표준화된 상거래 서식 또는 공공 서식을 서로 합의된 표준에 따라 전자문서를 만들어 컴퓨터 및 통신을 매개로 상호교환 하는 것  CALS(Commerce At Lighted Speed, 광속 상거래) : 각종 기술 자료를 디지털화하여 관련 데이터를 통합 운영하는 업무 환경            분야      주요 솔루션                  물류 부문      1. 종합물류정보망(실시간 차량추적) : 전자지도상에서 운행중인 차량의 위치 및 상태를 실시간으로 파악하여 서비스 가입자의 합리적인 의사결정을 지원하는 시스템2. 부가가치통신망(VAN, Value Added Network) : 네트워크에 단순한 전송 기능 이상의 부가가치를 첨가하여 정보를 축적, 가공, 변환 처리하여 음성 또는 데이터 정보를 제공해주는 광범위하고 복합적인 통신서비스의 집합              지리 부분      국가지리정보체계(NGIS), GS, GPS              교통 부분      지능형교통시스템(ITS)              의료 부분      의료 EDI              교육 부분      교육행정정보시스템(NEIS)         4. DW의 4대 특성   데이터 주제 지향성  데이터 통합  데이터의 시계열성  데이터의 비휘발성   5. BI VS BA             구분      BI(Business Intelligence)      BA(Business Analytics)                  목적      과거의 성과를 측정하고 향후 비즈니스를 계획      데이터와 통계를 기반으로 성과에 대한 이해와 비즈니스 통찰력에 초점을 둔 분석 방법              응용      데이터 기반의 의사결정      사전예측하고 최적화하기 위함BI 보다 진보된 형태      ",
        "url": "//data%20science/adsp/2018/08/20/ADsP-3.html"
      }
      ,
    
      "data-20science-adsp-2018-08-20-adsp-2-html": {
        "title": "(ADsP 1과목) 1-2. 데이터의 이해 - 데이터베이스의 정의와 특징",
        "tags": "ADsP-Part1",
        "date": "August 20, 2018",
        "author": "",
        "category": "",
        "content": "   1. 데이터베이스의 정의   동시에 복수의 적용 업무를 지원할 수 있도록 복수 이용자의 요구에 대응해서 데이터를 받아들이고 저장, 공급하기 위하여 일정한 구조에 따라서 편성된 데이터의 집합  관련된 레코드의 집합  소프트웨어로는 데이터베이스 관리 시스템(DBMS)을 의미한다.  DBMS는 이용자가 쉽게 데이터베이스를 구축하고 유지할 수 있도록 하는 소프트웨어로서 데이터베이스와 구분되며, 일반적으로 데이터베이스와 DBMS를 함께 데이터베이스 시스템이라고 한다.   2. 데이터베이스의 특징   통합된 데이터(Integrated data) : 데이터베이스에서 동일한 내용의 데이터가 중복되어 있지 않음  저장된 데이터(Stored data) : 컴퓨터가 접근할 수 있는 저장 매체에 저장되는 것  공용 데이터(Shared data) : 여러 사용자가 서로 다른 목적으로 데이터베이스의 데이터를 공동 이용  변화되는 데이터 : 새로운 데이터의 추가, 기존 데이터의 삭제, 갱신으로 항상 변화하면서도 항상 현재의 정확한 데이터를 유지해야 한다   3. 데이터베이스의 특성   정보의 축적 및 전달 측면          기계가독성 : 대량의 정보를 정보처리기기가 읽고 쓸수 있음      검색가능성 : 필요한 정보를 검색할 수 있음      원격조작성 : 정보통신망을 이용하여 원거리에서도 온라인으로 이용할 수 있음        정보이용 측면 : 이용자의 정보 요구에 따라 다양한 정보를 신속하게 획득하고 원하는 정보를 경제적으로 찾아 낼 수 있음  정보관리 측면 : 방대한 양의 정보를 체계적으로 축적하고 새로운 내용 추가나 갱신이 용이함  정보기술발전 측면 : 데이터베이스는 정보처리, 검색, 관리 소프트웨어 등 네트워크 발전기술을 견인할 수 있음  경제, 산업적 측면 : 데이터베이스는 인프라로서 특성을 가지고 있어 경제, 산업, 사회 활동의 효율성을 제고하고 국민의 편의를 증진하는 수단으로 의미를 가짐",
        "url": "//data%20science/adsp/2018/08/20/ADsP-2.html"
      }
      ,
    
      "data-20science-adsp-2018-08-20-adsp-1-html": {
        "title": "(ADsP 1과목) 1-1. 데이터의 이해 - 데이터와 정보",
        "tags": "ADsP-Part1",
        "date": "August 20, 2018",
        "author": "",
        "category": "",
        "content": "   1. 데이터의 정의   데이터는 객관적 사실(fact)이라는 존재적 특성을 가진다.-&gt; 데이터는 개별 데이터 자체로는 의미가 중요하지 않은 객관적 사실을 말한다.  데이터는 추론, 예측, 전망, 추정을 위한 근거(basis)로 기능하는 당위적 특성을 가진다.-&gt; 다른 객체와의 상호 관계 속에서 가치를 갖는다.   2. 데이터의 유형             구분      형태                  정성적 데이터(qualitative data)      언어, 문자 등 비정형 데이터(비정형 데이터) 자료의 성질, 특징을 설명 또는 요약  상대적으로 많은 비용과 기술적 투자가 수반된다.              정량적 데이터(quantitative data)      수치, 도형, 기호 등(정형 데이터)  자료를 수치화  저장, 검색, 분석 활용에 용이하다.         3. 지식경영 핵심 이슈   암묵지 : 학습과 체험을 통하여 개인에게 습득되지만 겉으로는 드러나지 않는 상태의 지식  형식지 : 암묵지가 문서나 메뉴얼처럼 외부로 표출되어서 여러 사람이 공유할 수 있는 지식  지식경영(knowledge management): 개인의 암묵지와 집단에서의 형식지가 나선형의 형태로 회전하면서 생성, 발전, 전환되는 지식의 발전을 기반으로한 기업의 경영  지식 나선 활동(creative route)            암묵지(Tacit knowledge)      형식지(Explicit knowledge)                  공통화(socialization)      표출화(Externalization)              내면화(internalization)      연결화(Combination)         4. 데이터와 정보의 관계   DIKW 피라미드(Data, Information, Knowledge, Wisdom)The DIKW pyramid (Source: Soloviev, K., 2016)            종류      설명      예시                  데이터(Data)      - 데이터를 가공하기 전의 순수한 수치나 기호 - 개별 데이터 자체로는 의미가 중요하지 않은 객관적인 사실      A 마트 100원, B마트는 200원에 연필을 판매한다.              정보(Information)      - 데이터의 가공 및 상관관계 간 이해를 통해 패턴을 인식하고 의미를 부여한 데이터 - 정보가 내포하는 의미는 유용하지 않을 수 있다.      A 마트의 연필 가격이 더 싸다.              지식(Knowledge)      - 상호 연결된 정보 패턴을 이해하여 이를 토대로 예측한 결과물 - 데이터를 통해 도출된 다양한 정보를 구조화하여 유의미한 정보로 분류하고 개인적인 경험을 결합시켜 고유의 지식으로 내재화 한 것      상대적으로 저렴한 A마트에서 연필을 사야겠다.              지혜(Wisdom)      - 근본 원리에 대한 깊은 이해를 바탕으로 도출되는 아이디어 - 지식의 축적과 깊은 이해를 바탕으로 도출되는 아이디어      A마트의 다른 상품들도 B마트보다 쌀 것이라고 판단한다.      ",
        "url": "//data%20science/adsp/2018/08/20/ADsP-1.html"
      }
      ,
    
      "data-20science-r-20programming-2018-08-15-r-4-html": {
        "title": "R programming - 그래프(Graph) 그리기",
        "tags": "R programming",
        "date": "August 15, 2018",
        "author": "",
        "category": "",
        "content": "   1. ggplot2 패키지 설치 파이썬의 matplotlib와 같은 기능을 제공하는 패키지는 R에서 ggplot2라는 패키지 이다. 그래프를 그리려면 먼저 ggplot2 패키지를 설치해야 한다. R studio의 콘솔(Console)창에서 아래의 명령어로 ggplot2 패키지를 설치 할 수 있다.install.packages(\"ggplot2\")ggplot2가 설치 된 후 사용할 수 있도록 패키지를 로드 해야한다. 콘솔창을 통해 로드하는 명령어는 다음과 같다.library(ggplot2)주의해야 할 점은 R studio를 새로 킬 때마다 패키지를 로드해줘야한다. 프로젝트를 키면 간단하게 File창/Packages에서 ggplot2를 찾아서 클릭해주면 자동으로 로드가 된다. 또는 새로 키고 난 후 위의 로드하는 명령어를 입력해주면 패키지가 로드 된다.주피터 노트북에 이미 r-essential이 설치되어 있다면 library(ggplot2)를 입력하고 사용하면 된다.  2. 그래프 그리기   references  (책) Do it! 쉽게 배우는 R 데이터 분석  http://antilibrary.org/407",
        "url": "//data%20science/r%20programming/2018/08/15/R-4.html"
      }
      ,
    
      "data-20science-r-20programming-2018-08-15-r-3-html": {
        "title": "R programming - Anaconda에 R 설치후 Jupyter notebook 사용하기(Windows10, MAC OS)",
        "tags": "R programming",
        "date": "August 15, 2018",
        "author": "",
        "category": "",
        "content": "&lt;p&gt;Anaconda에 R을 설치하면 Jupyter notebook에서 R 프로그래밍을 사용할 수 있다. 나는 R studio보다 Jupyter notebook이 조금 더 편해서 R 프로그래밍 환경을 Jupyter notebook으로 변경하였다.&lt;/p&gt;   1. Anaconda에서 R 설치 conda prompt에서 설치할 환경에 r을 설치한다. 나는 cuda라는 이름을 가진 아나콘다 환경에 R을 설치하려고 하므로 cuda로 conda 환경을 전환하고 설치하였다. # conda prompt 실행$ conda info --envs                 # 현재 존재하는 아나콘다 환경 확인$ activate cuda                     # cuda라는 이름을 가진 아나콘다 환경 활성(Windows)$ conda install -c r r-essentials   # R 패키지 설치맥을 이용해 설치한다면 아래와 같이 설치한다.# terminal 실행$ conda info --envs                 # 현재 존재하는 아나콘다 환경 확인$ source activate cuda                     # cuda라는 이름을 가진 아나콘다 환경 활성(MAC OS)$ conda install -c r r-essentials   # R 패키지 설치r-essentials를 설치하면 r에서 기본적으로 사용하는 패키지들이 모두 설치 된다.  2. jupyter notebook 켜서 확인Jupyter notebook 를 켜서 확인한다.R 환경이 추가된 것을 볼 수 있다!  references  https://datascienceschool.net/view-notebook/867d2d5bbafa491a807ffa7c0eb60f81/  https://anaconda.org/r/r-essentials",
        "url": "//data%20science/r%20programming/2018/08/15/R-3.html"
      }
      ,
    
      "data-20science-r-20programming-2018-08-15-r-2-html": {
        "title": "R programming - 변수(Variable)",
        "tags": "R programming",
        "date": "August 15, 2018",
        "author": "",
        "category": "",
        "content": "   1. 값 1개 가지는 변수 만들기 변수명은 대소문자를 구별하고 대시( - )나 언더바( _ ), 숫자를 조합하여 만들 수 있다. 한글 변수명도 가능하지만 오류가 날 수 있다. 변수명은 시작은 항상 소문자로 작성한다.(함수는 대문자) 변수 만드는 방법은 matlab과 비슷하다!a &lt;- 1    # a에 1할당a         # a출력   2. 사칙연산a &lt;- 1    # 변수 a에 값 1할당b &lt;- 2    # 변수 b에 값 2할당a+b       # a+b 덧셈 결과 출력b-a       # b-a 뺄셈 결과 출력b/2       # b/2 나눗셈 결과 출력a*b       # a*b 곱셈 결과 출력b%%a      # b/a의 나머지 결과 출력   3. 벡터 변수(여러 값으로 구성된 변수)와 연산 R의 내장 함수인 c()나 seq() 를 이용하여 여러값을 가진 변수를 만들수 있다. 즉, 파이썬의 리스트와 같은 개념이다. c()의 c는 combine의 앞글자 이며 seq()는 sequence의 줄임말이다.var1 &lt;- c(1,2,3,4,5)      # 숫자 5개로 구성된 변수 var1 생성 (type : numeric)var2 &lt;- c(1:5)            # 1부터 5까지 숫자 5개로 구성된 변수 var2 생성 (type : integer)var3 &lt;- seq(1,5)          # 1부터 5까지 숫자 5개로 구성된 변수 var3 생성 (type : integer)var4 &lt;- seq(1, 10, by =2) # 1부터 10까지 2간격으로 생성(1,3,5,7,9) (type : numeric)var5 &lt;- c(\"a\", \"b\", \"c\")  # \"a\" \"b\" \"c\" 3개의 문자로 구성된 변수 (type : character)var6 &lt;- c(\"hello\", \"world!\") # \"hello\" \"world!\" 2개의 문자열로 구성된 변수 (type : character)위의 결과를 보면 어떤 것은 변수 형이 numeric이고 어떤 것은 integer 형을 가진다. numeric은 integer보다 더 큰 그룹 개념이다. 데이터 형이 integer로 좁혀지는 이유는 디테일 할 수록 메모리가 덜 소모되기 때문이다. 파이썬의 numpy와 동일하게 벡터와 스칼라를 더했을때 모든 열에 스칼라 값을 더해준다. 벡터 크기가 같으면 각 열끼리 덧셈이 가능하다. 단, 벡터의 크기가 다르다면 벡터끼리 연산 할 수 없다. 또한, 문자열끼리 연산할 수 없다.var1 + 2       # 각 열에 2를 더해줌var1 + var2    # 연산 가능(같은 위치의 수끼리 더하기)var7 &lt;- c(1:6) # 1부터 6까지 숫자 6개로 구성된 변수 var7 생성(type : integer)var1+var7      # 벡터의 길이가 달라 오류 발생(var1의 길이는 5, var7의 길이는 6)var6 + 2       # 문자열은 연산 할 수 없다.  references  (책) Do it! 쉽게 배우는 R 데이터 분석  http://antilibrary.org/407",
        "url": "//data%20science/r%20programming/2018/08/15/R-2.html"
      }
      ,
    
      "data-20science-r-20programming-2018-08-15-r-1-html": {
        "title": "R programming 시작하기",
        "tags": "R programming",
        "date": "August 15, 2018",
        "author": "",
        "category": "",
        "content": "&lt;p&gt;ADsP를 준비하면서 R 프로그래밍을 처음 접하게 되었다. 데이터 분석하거나 가공할 때 파이썬의 numpy, pandas, matplotlib, scipy등의 패키지를 사용하여 정제하고 분석하였는데 파이썬 보다는 R이 통계적 분석을 하기에는 더 편리하다고 한다. R은 다양한 통계 패키지들을 사용하기 쉽도록 제공하고 대용량 데이터에서 속도가 파이썬보다 빠르다고 한다. 이번 기회에 R을 익혀 볼 예정이다. 항상 새로운 언어를 배울 때는 기초 교재를 1~2개 정도 사는 편인데 R 교재로는 Do it! 쉽게 배우는 R 데이터 분석을 선택하였다.&lt;/p&gt;   1. R Studio 먼저 R프로그래밍을 하려면 R Studio가 있어야 한다. R Studio는 Visual Studio 같은 IDE이다. 아래의 링크에서 운영체제에 맞는 것으로 설치한다.  R Studio : https://www.rstudio.com/R studio를 실행시켜보면 위의 이미지와 같은 4분할 창이 먼저 뜨게 된다.  스크립트(Script) 창 : R 코드 작성, 실행하고자 하는 행을 클릭후 run 실행(ctrl+Enter)  콘솔(Console) 창 : 명령어 1개 실행(프롬프트)  환경(Enviroment)          Enviroment : 데이터 정보 보여주는 창      History : 수행 내역      Connections : 데이터베이스 연결        파일(File)          working directory 정보      plots : 내가 그린 그래프 정보      packages : 설치된 패키지 목록         2. R studio 기본 셋팅 먼저 Soft-wrap 옵션을 설정한다. Tools/Global Options/Code에서 Soft wrap R source files를 체크한다.그 다음 프로젝트 파일을 1개 만들고 한글 깨짐을 방지하기 위해 Tools/Project Options/Code Editing에서 인코딩을 UTF-8로 설정한다.이렇게하면 기본 셋팅 끝! 이런 에디터 프로그램은 한글이 깨질 수 있기 때문에 항상 인코딩에 주의해야한다!  references  (책) Do it! 쉽게 배우는 R 데이터 분석",
        "url": "//data%20science/r%20programming/2018/08/15/R-1.html"
      }
      ,
    
      "data-20science-statistics-2018-08-14-statistics-3-html": {
        "title": "Basic Statistics - 표와 그래프",
        "tags": "Statistics, ADsP",
        "date": "August 14, 2018",
        "author": "",
        "category": "",
        "content": "&lt;p&gt; 이번에는 각 자료들의 종류에 따라서 표현할 수 있는 그래프를 정리하였다. &lt;/p&gt;  references  http://www.kmooc.kr/courses/course-v1:PNUk+RS_C01+2017_KM_009/info",
        "url": "//data%20science/statistics/2018/08/14/statistics-3.html"
      }
      ,
    
      "data-20science-statistics-2018-08-14-statistics-2-html": {
        "title": "Basic Statistics - 모집단(Population)과 표본(Sample)",
        "tags": "Statistics, ADsP",
        "date": "August 14, 2018",
        "author": "",
        "category": "",
        "content": "&lt;p&gt; 통계학은 용어가 조금 어렵고 많은 것 같다. 용어 위주로 정리하였으며 통계학의 아주 기초적인 모집단과 표본에 대하여 정리 하였다. &lt;/p&gt;  1. 모집단(Population)과 표본(Sample)   모집단(Population) : 분석하고자하는 전체 대상  표본(sample) : 모집단에서 표본 추출(sampling)한 집단  표본을 사용하는 이유 : 모집단의 크기가 크면 많은 시간과 비용이 들기 때문이다.  표본 추출의 이점 : 일부 추출한 표본을 분석하여 모집단의 특성을 추론할 수 있다.  2. 표본 추출(sampling) 방법 크게 확률적 추출(probability sampling)과 비확률적 추출(nonprobability sampling)으로 나뉜다.1) 확률적 추출(probability sampling)  단순 무작위 추출(simple random sampling) : 표본으로 선택될 확률은 모두 n/N으로 동일하다.  계통 추출(systematic sampling) : 일정 간격으로 표본을 선택한다.  층화 추출(stratified sampling) : 모집단을 성격에 따라 몇개의 집단 또는 층(strata)으로 나누고 집단 내에서 원하는 크기의 표본을 무작위로 추출한다.  군집 추출(cluster sampling) : 모집단을 특성에 따라 여러개의 집단(cluster)으로 나누고 몇개의 집단을 선택한 후 선택된 집단 내에서 필요한 만큼의 표본을 무작위로 추출한다.2) 비확률적 추출(nonprobability sampling)  판단 추출(judgement sampling) : 연구자가 자신의 판단에 따라 표본을 선택한다.  할당 추출(quota sampling) : 모집단을 여러 집단으로 나눈 후 연구자가 자신에 판단에 따라서 집단에서 필요한 표본의 개수를 선택해 추출한다.  편의 추출(convenience sampling) : 연구자가 쉽게 접근할 수 잇는 표본을 선택한다.  3. 자료의 종류  Data : Datum(자료, 정보)의 복수형, 통계학은 자료(재료)를 이용해서 정보(요리)를 만들어 내는 것이다.자료는 크게 양적 자료와 질적 자료로 나눌 수 있으며 양적자료는 연속형 자료, 이산형 자료로로 나눌 수 있꼬 질적 자료에는 명목형 자료, 순서형 자료로 나눌 수 있다.  references  http://www.kmooc.kr/courses/course-v1:PNUk+RS_C01+2017_KM_009/info",
        "url": "//data%20science/statistics/2018/08/14/statistics-2.html"
      }
      ,
    
      "data-20science-statistics-2018-08-14-statistics-1-html": {
        "title": "Basic Statistics - 통계학(Statistics)과 데이터(Data)",
        "tags": "Statistics, ADsP",
        "date": "August 14, 2018",
        "author": "",
        "category": "",
        "content": "&lt;p&gt; 이번 방학이 끝나기 전에 자격증을 하나 따보자! 해서 신청한게 ADsP(데이터 분석 준전문가) 시험이다. 데이터 분석에 관한 자격증이 뭐가 있나 봤더니 이게 있었다! 실제로 통계학과 분들은 이 자격증을 많이 따기도 하고 따는 사람을 본적도 있다. 취업시 많은 혜택이 있는 자격증은 아니지만 어느정도 가산점이 있고 기초를 자세히 정리하기에 좋을 것 같아서 신청하고 시험 준비중이다! 나는 통계학과 학생은 아니지만… 어느정도 머신러닝 프로그래밍을 하면서 약간의 지식은 가지고 있고 통계학만.. 잘 다루면 되지 않을까해서 일단 도전! 해보는 것이다. 이 자격증과 관련된 네이버 카페도 있는데 한 3주정도면 다들 취득할 수 있다고들 한다. 원래 저번주에 신청했지만… 갑자기 연구실 일이 폭풍같이 밀려들어서… 사실 지금 시작하는거와 다름없다. 8월 25일이 시험인데 걱정된다 ㅠ.ㅠ 학부때 통계학개론 교양 수업을 들었지만… c+이라는 아픈 기억이 있으므로 통계학 개론 기초 수업을 찾아서 들었다. 강의 이름은 K-MOOC R을 활용한 통계학개론 이라는 강의이다. 간단 명료하게 강의내용이 딱딱 정리되어 있는 스타일이라서 좋았다. 이 수업의 통계학 개론 내용과 ADsP에서 필요한 통계학 내용과 결합하여 정리할 예정이다.&lt;/p&gt;  1. 통계학이란? 통계학(Statistics)이란 Status(국가)와 ics(학문)라는 접미어를 합쳐서 만든 단어로 국가의 경영 또는 통치에 필요한 학문이라는 뜻이다. 과거의 통계학은 경제 관련자료에 대한 기록을 주로 다뤘다면 현재의 통계학은 수학을 바탕으로 더 과학적이고 논리적 체계를 갖춘 학문으로 발전하였다. 통계학은 자료가 발생될 수 있는 모든 분야에서 활용이 가능하며 특히 빅데이터에 통계학적인 지식을 많이 접목하여 활용하고 있다.  2. 빅 데이터(Big Data)란? 빅 데이터의 특징은 3V로 표현 될 수 있다. 3V는 Velocity(데이터의 발생 속도), Volume(데이터의 크기), Variety(데이터의 다양성)을 가리킨다.  Velocity(데이터의 발생 속도) : Velocity 관점에서 두가지로 해석 될 수 있다. 데이터가 빠른 속도로 발생한다, 사용자가 원하는 시간에 데이터 분석 결과를 제공한다.  Volumn(데이터의 크기) : 데이터의 양이 방대하다.  Variety(데이터의 다양성) : 정형화된 데이터를 넘어 텍스트, 오디오, 비디오 등 모든 유형의 데이터를 분석대상으로 한다.  3. 인공지능(AI, Artificial Intelligence)과 데이터(Data)인공지능은 입력은 반드시 데이터의 형태를 가지며 입력된 자료를 분석하여 최적의 분류(classification)을 할 수 있는 기계(machine)을 가리킨다.훈련자료를 기계(machine)에 input으로 넣어 기계가 자료를 분석하여 학습한 기계를 인공지능이라고 하며 기계가 자료를 분석하여 분류할 수 있도록 학습하는 과정을 머신러닝(machine learning)이라고 한다.머신러닝의 종류에는 단순 학습(shallow learning)과 심화 학습(deep learning)이 있다.단순학습(shallow learning)은 어떠한 filter를 이용해 단순히 예측값을 도출하는 반면 심화 학습(deep learning)은 인간의 신경망을 본뜬 알고리즘으로 기계 스스로 학습하며 정답값이 주어지면 hidden layers를 통해 기계 스스로 학습하며 어떠한 이유로 그렇게 학습되는지 명확하게 규명할 수 없다. 또한, 도출된 예측값을 다시 input data로 활용하여 여러번 반복하여 학습하므로 shallow learning 보다는 더욱 복잡한 예측이 가능하다.인공지능의 핵심기술은 크게 음성인식(Voice Recognition)과 형상인식(Pattern Recognition)으로 나뉠 수 있다.  references  http://www.kmooc.kr/courses/course-v1:PNUk+RS_C01+2017_KM_009/info",
        "url": "//data%20science/statistics/2018/08/14/statistics-1.html"
      }
      ,
    
      "python-crawler-2018-08-13-crawler-4-html": {
        "title": "Selenium으로 로딩한 페이지의 html 파싱 - BeautifulSoup",
        "tags": "Selenium, BeautifulSoup",
        "date": "August 13, 2018",
        "author": "",
        "category": "",
        "content": "저번 포스팅에 이어서 원하는 탭으로 이동하였고 원하는 정보를 수집할 수 있게 되었다. 이번에는 셀레니움을 이용하여 로딩한 페이지의 html을 추출하고 beautifulsoup 사용 방법을 간단하게 정리하였다.  1. Beautifulsoup 설치먼저 html을 크롤링하고 파싱하기 위해서는 BeautifulSoup 패키지가 필요하다. 아나콘다를 사용하면 이미 설치되어 있지만 아니라면 pip 를 이용하여 패키지를 설치해야한다.$ pip install bs4  2. selenium으로 로딩한 페이지의 HTML 파싱  먼저 selenium을 통해 해당 페이지의 html 소스를 가져온다. 이 html 소스를 beautifulsoup에 넣어주면 태그명, css 클래스명, id, css selector 등으로 html 파싱이 가능하다.# 페이지 소스 가져오기html = driver.page_source# soup에 넣어주기soup = BeautifulSoup(html, 'html.parser')print(soup.text)  3. BeautifulSoup 시작하기 예시 HTML 구조로 BeautifulSoup 문서에 있는 html 코드를 이용하였다.from bs4 import BeautifulSouphtml = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;Elsie&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"soup = BeautifulSoup(html, 'html.parser')html 파일을 예쁘게 보고싶다면 아래의 함수를 이용하여 출력 가능하다.print(soup.prettify())soup을 이용한 html 구조는 트리 구조를 띈다. 따라서 soup을 이용하여 다음과 같은 접근이 가능하다.# soup 내의 text 모두 추출print(soup.get_text())# \"The Dormouse's story\\n\\nThe Dormouse's story\\nOnce upon a time there were three little sisters; and their names were\\nElsie,\\nLacie and\\nTillie;\\nand they lived at the bottom of a well.\\n...\"soup.title# &lt;title&gt;The Dormouse's story&lt;/title&gt;soup.title.name# 'title'soup.title.string# \"The Dormouse's story\"  4. BeautifulSoup 태그 파싱 위의 html 구조 예시에서 a 태그를 모두 수집하고 싶다면 위처럼 단순 트리구조가 아닌 find_all()이라는 함수를 이용하면 된다. find_all() 함수는 해당 조건에 맞는 모든 값들(여러개)을 리스트로 반환해준다. 맨 처음 1개의 값만 받고 싶다면 find() 함수를 사용하면 된다. find_all() 사용방법은 아래와 같다.# 단순히 tree 구조로 검색하면 맨 위에 있는 a 태그만 추출할 수 있다.soup.a# &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;# 태그명으로 찾기(a 태그 모두 수집)soup.find_all('a')#[&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;,# &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;,# &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;]css 클래스 명과 태그 id로도 파싱이 가능하다. python의 class와 구분하기 위해서 파라미터는 class_ 를 사용한다.# css class 명으로 찾기(class 이름이 sister인 태그 모두 수집)soup.find_all(class_='sister')#[&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;,# &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;,# &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;]# a 태그의 css class 이름이 'sister'인 태그 모두 수집soup.find_all('a', class_='sister')#[&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;,# &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;,# &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;]# id 가 link1인 태그 수집soup.find_all(id='link1')# [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;]css selector를 이용한 파싱도 가능하다. find_all() 함수 대신 select()라는 함수를 사용한다. css selector 값은 크롬 개발자 도구를 이용하면 쉽게 값을 알아낼 수 있다.(태그 select -&gt; 마우스 오른쪽 버튼 -&gt; copy -&gt; copy selector) soup.select('title')# [&lt;title&gt;The Dormouse's story&lt;/title&gt;]# 3번째 p 태그soup.select('p:nth-of-type(3)')# [&lt;p class=\"story\"&gt;...&lt;/p&gt;]# body 태그 안의 a 태그 모두soup.select('body p')# [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;,# &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;,# &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;]soup.select('body &gt; a')# [] -&gt; '&gt;'를 사용할 때는 태그 순서를 고려해야한다.# 반드시 '&gt;' 양 옆에는 띄어쓰기를 해야한다. (body&gt;a 는 올바른 결과를 찾을 수 없음)# p 태그 안의 a 태그 모두soup.select('p &gt; a')# [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;,# &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;,# &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;]# p 태그 안에 id가 link1인 태그soup.select('p &gt; #link1')# [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;]# id가 link1과 link2인 태그 모두soup.select('#link1, #link2')# [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;]# a태그이고 id가 link1인 태그soup.select('a#link1')# [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;]# css 클래스가 sister인 태그 모두(두 코드 결과 같음)soup.select('.sister')soup.select('[class~=sister]')# [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;,# &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;,# &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;]# id가 link1이고 css 클래스가 sister인 태그의 자매(sibilings) 태그들 (같은 계층)# '~' 양 옆에 띄어쓰기 필수soup.select('#link1 ~ .sister')# [&lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;,# &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;]# id가 link1이고 css 클래스가 sister인 태그의 바로 옆의 자매(sibling) 태그# '+' 양 옆에 띄어쓰기 필수soup.select('#link1 + .sister')# [&lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;]이외에도 find_next_siblings(), find_next_sibling(), find_previous_siblings(), find_previous_sibling() 같은 탐색 함수와 다양한 기능의 파싱 함수들도 제공한다. 위의 내용은 beautifulsoup를 다루기 위한 기본적인 내용들이며 자세한 사항들은 beautifulsoup 공식 문서를 참고하면 예시와 함께 자세히 설명되어 있다.  reference  https://kiddwannabe.blog.me/221288079822  https://www.crummy.com/software/BeautifulSoup/bs4/doc/",
        "url": "//python/crawler/2018/08/13/crawler-4.html"
      }
      ,
    
      "python-crawler-2018-08-13-crawler-3-html": {
        "title": "Python Selenium(셀레니움) 크롬창 활성 탭 변경하기",
        "tags": "Selenium",
        "date": "August 13, 2018",
        "author": "",
        "category": "",
        "content": "JCR 홈페이지에서 로그인을 한 뒤에 검색을 하면 새로운 탭이 켜지고 새로운 탭에 검색결과가 나타났다. 그래서 셀레니움을 통해 활성 탭을 변경하고 검색 내용을 수집할 수 있는 방법을 검색하여 찾아 보았다. 이전 포스팅에 이어서 수행 결과를 정리하였다.   1. 검색 자동화 먼저 위의 이미지와 같은 검색 창에서 검색 할 수 있도록 프로그램을 작성한다.   검색창에 검색 어 입력  검색어 입력시 하단에 나오는 버튼 클릭이전 코드에 이어서(로그인 버튼 누르기 다음) 아래에 추가한 코드는 다음과 같다. # 키워드 검색input = 'Peer-to-Peer Networking and Applications'# 검색창에 키워드 입력후 검색search = driver.find_element_by_name('search-inputEl')search.send_keys(input)# 검색창 하단에 표시되는 버튼 클릭driver.find_element_by_xpath('//*[@id=\"boundlist-1029-listEl\"]/ul/li').click()time.sleep(5) # 로딩 기다리기  2. 활성 탭 전환하기위의 코드를 이용하여 검색창에 검색어를 입력하여 검색은 가능하다. 검색 결과가 새창에 나타나므로 새로 활성화 된 창으로 화면을 변경하여야 한다. 아래의 코드를 추가함 으로써 탭 전환이 가능하다.먼저 아래의 명령어는 탭 목록들을 보여준다. 새로운 탭을 열고 로딩을 기다린뒤 윈도우 목록을 확인해보면 리스트에 두개의 항목이 들어있는 것을 볼 수 있다.print(driver.window_handles)  결과 : [‘CDwindow-5869F32E71D5DF1303F64200A76D021F’, ‘CDwindow-19FEAEAE68751A47C2CD0D9008B6BF4E’]새롭게 열린 탭으로 변경하는 코드는 아래의 코드를 추가하면 된다.# 최근 열린 탭으로 전환driver.switch_to.window(driver.window_handles[-1])# 로딩 기다리기time.sleep(5)만약에 새로 옮긴 탭을 닫고 다시 원래 창으로 돌아가고 싶다면 아래의 코드를 입력하면 된다.# 현재 탭 닫기driver.close()# 맨 처음 탭으로 변경(0번 탭)driver.switch_to.window(driver.window_handles[0])# 로딩 기다리기time.sleep(5)수정한 전체 코드는 아래와 같다.from selenium import webdriveroptions = webdriver.ChromeOptions()# headless 옵션 설정options.add_argument('headless')options.add_argument(\"no-sandbox\")# 브라우저 윈도우 사이즈options.add_argument('window-size=1920x1080')# 사람처럼 보이게 하는 옵션들options.add_argument(\"disable-gpu\")   # 가속 사용 xoptions.add_argument(\"lang=ko_KR\")    # 가짜 플러그인 탑재options.add_argument('user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36')  # user-agent 이름 설정# 드라이버 위치 경로 입력driver = webdriver.Chrome('./chromedriver.exe', chrome_options=options)# url을 이용하여 브라우저로 접속driver.get('https://error.incites.thomsonreuters.com/error/Error?DestApp=IC2JCR&amp;Error=IPError&amp;Params=DestApp%3DIC2JCR&amp;RouterURL=https%3A%2F%2Flogin.incites.thomsonreuters.com%2F&amp;Domain=.thomsonreuters.com&amp;Src=IP&amp;Alias=IC2')driver.implicitly_wait(3)# 아이디/비밀번호를 입력해준다.driver.find_element_by_name('username').send_keys('아이디 입력')driver.find_element_by_name('password').send_keys('비밀번호 입력')# stay signed in 체크박스 채우기(클릭)driver.find_element_by_name('rememberme').click()# 로그인 버튼을 누르기driver.find_element_by_xpath('/html/body/div/div[1]/div[3]/div[1]/div/div/div/form/button').click()# 키워드 검색input = 'Peer-to-Peer Networking and Applications'# 검색창에 키워드 입력후 검색 버튼 클릭search = driver.find_element_by_name('search-inputEl')search.send_keys(input)driver.find_element_by_xpath('//*[@id=\"boundlist-1029-listEl\"]/ul/li').click()time.sleep(5)print(driver.window_handles)# 새로 열린 탭으로 활성 탭 변경driver.switch_to.window(driver.window_handles[-1])time.sleep(5)# 로그인 된 화면 캡처driver.get_screenshot_as_file('capture.png')driver.quit()  reference  https://kiddwannabe.blog.me/221288079822",
        "url": "//python/crawler/2018/08/13/crawler-3.html"
      }
      ,
    
      "data-20base-mysql-2018-08-13-mysql-1-html": {
        "title": "Homebrew를 이용하여 MYSQL 설치 - MAC",
        "tags": "MYSQL, Homebrew, MAC",
        "date": "August 13, 2018",
        "author": "",
        "category": "",
        "content": "나는 노트북을 맥을 사용하는데 맥에서는 homebrew 라는 패키지 관리자를 설치하여 사용할 수 있다. 프로그램 설치시 유용하게 활용하고 있다. 개발 환경을 조금 더 편리하게 구성할 수 있어 편리하였다. MYSQL도 homebrew를 이용하여 편리하게 설치할 수 있다.    1. Homebrew 설치 아래의 사이트를 참고하여 homebrew를 설치할 수 있다.  homebrew : https://brew.sh/index_ko맥에는 루비가 설치되어 있으므로 다음의 루비 명령어를 통해서 homebrew를 설치할 수 있다. 명령어를 실행하면 homebrew가 자동으로 설치 된다.$ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"  2. mysql server 설치 일단 mysql을 사용하려면 mysql server와 mysql 데이터베이스를 GUI로 확인가능한 mysqlworkbench를 homebrew를 이용하여 설치한다. 우선 brew 명령어를 통해서 mysql에 관련된 프로그램들을 검색할 수 있다.$ brew doctor$ brew search mysql위의 이미지에서 formulae 의 mysql과 mysql-client casks의 mysqlworkbench를 설치한다. mysql-client는 커맨드라인에서 mysql 서버 접속시 사용된다.$ brew install mysql$ brew install mysql-client$ brew cask install mysqlworkbench이렇게 해서 mysql 서버와 mysqlworkbench 설치가 완료되었다.  3. mysql 실행 확인아래의 명령어를 실행하면 mysql 커맨드라인으로 접속이 가능하도록 설정 할 수 있다.$ brew services start mysql==&gt; Tapping homebrew/servicesCloning into '/usr/local/Homebrew/Library/Taps/homebrew/homebrew-services'...remote: Counting objects: 14, done.remote: Compressing objects: 100% (10/10), done.remote: Total 14 (delta 0), reused 7 (delta 0), pack-reused 0Unpacking objects: 100% (14/14), done.Tapped 1 command (43 files, 55.2KB).==&gt; Successfully started `mysql` (label: homebrew.mxcl.mysql)그 다음 커맨드라인 명령어로 접속하면 root 계정으로 접속이 되는 것을 확인 할 수 있다.$ mysql -urootroot 계정에 비밀번호를 설정하고 싶다면 아래의 명령어를 실행하면된다.$ mysql_secure_installation......Press y|Y for Yes, any other key for No: noPlease set the password for root here.New password:패스워드 입력Re-enter new password: 패스워드 확인.....Remove anonymous users? (Press y|Y for Yes, any other key for No) : ySuccess.Disallow root login remotely? (Press y|Y for Yes, any other key for No) : ySuccess.Remove test database and access to it? (Press y|Y for Yes, any other key for No) : y - Dropping test database...Success. - Removing privileges on test database...Success......Reload privilege tables now? (Press y|Y for Yes, any other key for No) : ySuccess.All done!  4. mysqlworkbench로 mysql 접속하기  이제 mysqlworkbench로 접속하기 위하여 한가지 권한 셋팅을 해야한다. 권한 셋팅을 하지 않으면 아래의 오류가 발생한다. MYSQL 8.0 오류라고 한다.Authentication plugin 'caching_sha2_password' cannot be loaded: dlopen(/usr/local/mysql/lib/plugin/caching_sha2_password.so, 2): image not found먼저 mysql을 커맨드 라인으로 접속한다.(root계정 패스워드 0000)$ mysql -uroot -p0000그 다음 아래의 쿼리를 날려 권한 수정을 해준다.mysql&gt; ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '0000';권한 설정을 해준뒤 워크벤치로 접속하면 접속이 되는 것을 확인할 수 있다.  reference  https://github.com/helloheesu/SecretlyGreatly/wiki/%EB%A7%A5%EC%97%90%EC%84%9C-mysql-%EC%84%A4%EC%B9%98-%ED%9B%84-%ED%99%98%EA%B2%BD%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0  https://github.com/appkr/l5code/issues/4  https://stackoverflow.com/questions/49194719/authentication-plugin-caching-sha2-password-cannot-be-loaded",
        "url": "//data%20base/mysql/2018/08/13/mysql-1.html"
      }
      ,
    
      "development-20environment-github-20blog-2018-08-12-blog-8-html": {
        "title": "Jekyll 블로그 카테고리 계층 만들기 - Permalink 이용",
        "tags": "Github Blog",
        "date": "August 12, 2018",
        "author": "",
        "category": "",
        "content": "&lt;p&gt;점점 카테고리 항목이 늘어나서 기존 카테고리 방법을 응용(?)한 카테고리 표현 방법으로 변경하였다. 나중에 혹시 또 변덕이 생겨서 변경하게 될지도 모르므로 블로그에 기록을 남겨두기로 하였다. 많은 삽질과 고민끝에 아래의 이미지의 카테고리로 수정하였다.&lt;/p&gt;상위카테고리 Home, Python, Data Science, Development, Android를 가지고 각각 상위카테고리에 하위 카테고리가 있는 형식이다. 예를들어, Python 항목을 누르면 하위 카테고리들의 포스트들을 모두 보여주고 싶었는데 수정하려고 하니 내 역량 밖이였다 ㅠㅠ 수정 내용을 차례로 정리하였다.  1. _includes/header.html 파일 수정원래 기존에 _includes/index.html 에 카테고리 구조를 적어 놓았다. 하지만 모두 header 영역으로 취급하고 싶어서 _includes/index.html 파일을 제거하고 _includes/header.html 파일에 카테고리 구조를 표현하였다.홈페이지 상단의 헤더부분은 branding 부분(로고, 블로그명, About, tag, search)과 카테고리 영역으로 나누었다.기존의 header.html파일에 추가한 내용 아래와 같다. header 태그 안에 삽입하여 카테고리 영역을 추가한다. &lt;div class=\"site-category\"&gt;    &lt;ul class='cat1'&gt;      &lt;li&gt;&lt;a href=\"/\"&gt;Home&lt;/a&gt;&lt;/li&gt;      &lt;li&gt;&lt;a href=\"/\"&gt;Python&lt;/a&gt;        &lt;ul&gt;            &lt;li&gt;&lt;a href=\"/Python/Crawler\"&gt;Crawler&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=\"/Python/Django\"&gt;Django&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=\"/Python/Tensorflow\"&gt;Tensorflow&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt;      &lt;/li&gt;      &lt;li&gt;&lt;a href=\"/\"&gt;Data Science&lt;/a&gt;        &lt;ul&gt;          &lt;li&gt;&lt;a href=\"/DS/ML\"&gt;Machine Learning&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt;      &lt;/li&gt;      &lt;li&gt;&lt;a href=\"/\"&gt;Development Enviroment&lt;/a&gt;        &lt;ul&gt;            &lt;li&gt;&lt;a href=\"/DE/Github Blog\"&gt;Github Blog&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=\"/DE/Git\"&gt;Git&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=\"/DE/Docker\"&gt;Docker&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=\"/DE/Ubuntu\"&gt;Ubuntu&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=\"/DE/Java\"&gt;Java&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt;      &lt;/li&gt;      &lt;li&gt;&lt;a href=\"/\"&gt;Android&lt;/a&gt;        &lt;ul&gt;          &lt;li&gt;&lt;a href=\"/Android/Android\"&gt;Android&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt;      &lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;각 카테고리의 링크는 나중에 permalink라는 기능을 이용하여 각 페이지와 링크 시킬 예정이므로 a 태그안의 href는 permalink 항목의 내용으로 채워두었다.   2. _sass/_header.scss 수정css 파일을 수정하여 디자인을 적용한다. 디자인은 아래의 코드를 응용하여 수정하였다.  http://jsfiddle.net/SRV36/1633/추가 코드는 아래와 같다..site-category{  background: $brand-color;  border-top: 1px solid $border-color;  margin:auto;  padding:0;  font-size:14px;  text-align: center;  clear:left;  }  .site-category ul{  //background: rgb(109,109,109);  height:50px;  list-style:none;  line-height: 1.5;  margin:0 auto;  padding:0;  display:inline-block;  }  .site-category li{  float: left;  display:inline;  }  .site-category li a{  background: $brand-color;  display:block;  font-weight:normal;  line-height:50px;  margin:0px;  padding:0px 25px;  text-align:center;  text-decoration:none;  }  .site-category li a:hover{  background: rgb(71,71,71);  color:#FFFFFF;  text-decoration:none;  }  .site-category li ul{  background: rgb(109,109,109);  display:none; /* 평상시에는 드랍메뉴가 안보이게 하기 */  height:auto;  padding:0px;  margin:0px;  border:0px;  position:absolute;  width:200px;  z-index:200;  /*top:1em;  /*left:0;*/  }  .site-category li:hover ul{  display:block; /* 마우스 커서 올리면 드랍메뉴 보이게 하기 */  }  .site-category li li {  background: $brand-color;  display:block;  float:none;  margin:0px;  padding:0px;  width:200px;  }  .site-category li:hover li a{  background:none;  }  .site-category li ul a{  display:block;  height:50px;  font-size:12px;  font-style:normal;  margin:0px;  padding:0px 10px 0px 15px;  text-align:left;  }  .site-category li ul a:hover, .menubar li ul li:hover a{  background: rgb(71,71,71);  border:0px;  color:#ffffff;  text-decoration:none;  }}   3. category 폴더 안의 .md 파일들 수정이제 permalink 라는 기능으로 각 버튼들과 페이지를 연결해주어야 한다. 아래의 이미지와 같이 마크다운 파일들을 수정한다.    reference   http://re-fresh-studio.com/2013/07/post-12-dropmenu_with_css.php",
        "url": "//development%20environment/github%20blog/2018/08/12/blog-8.html"
      }
      ,
    
      "python-crawler-2018-08-11-crawler-2-html": {
        "title": "Python Selenium(셀레니움)으로 홈페이지 로그인하기",
        "tags": "Selenium",
        "date": "August 11, 2018",
        "author": "",
        "category": "",
        "content": "논문 Impact factor를 수집할 때 JCR 이라는 사이트에서 확인 할 수 있는데 로그인을 해야 JCR 사이트를 이용할 수 있었다. 따라서, 셀레니움 프로그램 내에서 자동으로 로그인을 하여 수집하는 방향으로 진행하였다. JCR 사이트를 이용하기 위해서는 계정이 필요하므로 미리 계정을 생성하여 준다.  1. 홈페이지 html dom 분석셀레니움을 통하여 자동화 할 내용은 다음과 같다.  JCR 로그인 페이지 접속  아이디 입력 폼에 아이디 입력  비밀번호 입력 폼에 비밀번호 입력  Stay signed in 체크박스 체크  로그인 버튼 눌러서 로그인하기먼저 수집기를 만들기전에 수집 하고자하는 홈페이지의 html 구조 분석이 필요하다. 구글에 JCR을 검색하여 홈페이지에 들어가면 바로 로그인 창으로 넘어간 화면이 뜬다. 셀레니움 프로그램에서 아래의 url을 통해 JCR 홈페이지에 접속할 것이다.  JCR 접속 url : https://error.incites.thomsonreuters.com/error/Error?DestApp=IC2JCR&amp;Error=IPError&amp;Params=DestApp%3DIC2JCR&amp;RouterURL=https%3A%2F%2Flogin.incites.thomsonreuters.com%2F&amp;Domain=.thomsonreuters.com&amp;Src=IP&amp;Alias=IC2크롬 개발자 도구(맨 오른쪽 점 3개짜리 버튼-&gt;도구더보기-&gt;개발자 도구)를 켜고 select an element 버튼을 이용하여 각 요소별 html 구조 분석이 가능하다.select an element 버튼은 이미지에서 파란색으로 표시된 버튼이다. 이 버튼을 누르고 html 요소를 클릭하면 html 파일에서 이 요소가 있는 위치로 이동해서 보여준다.먼저 개발자 도구를 이용하여 아이디 폼의 구조를 확인해보면 이름이 username 인 것을 알 수 있다. xpath라는 xml 구조도 찾을 수 있는데 찾은 html 위치에서 오른쪽클릭 -&gt; copy -&gt; copy xpath를 클릭하면 자동으로 클립보드에 복사되고 ctrl+c로 붙여넣기 하면 사용할 수 있다. 또한 여기서 이 요소의 css selector 값도 구할 수 있다.정리하면 아이디 input 폼의 이름은 username 이고 xpath의 값은 //*[@id=\"username\"] 이다.비밀번호 input 폼도 동일한 방법으로 확인하면 이름은 password 이고 xpath의 값은 //*[@id=\"password\"] 이다.Stay signed in 체크박스 input 폼의 이름은 rememberme 이고 xpath의 값은 //*[@id=\"rememberme\"] 이다.로그인 버튼인 Sign in 버튼은 이름은 존재하지 않고 xpath의 값은 /html/body/div/div[1]/div[3]/div[1]/div/div/div/form[1]/button 이다.수집한 정보를 이제 셀레니움 코드에 적용해보자.  2. 셀레니움 코드 작성이전 포스팅에서 작성했던 코드에서 시작하면 driver.get() 부분에 접속하고자 하는 url로 변경해주어 접속한다. name이 존재하는 element들(아이디, 비밀번호 입력 폼)은 find_element_by_name 함수로 접근 할 수 있고 로그인 버튼은 find_element_by_xpath 함수로 접근할 수 있다. 코드는 아래와 같다.from selenium import webdriveroptions = webdriver.ChromeOptions()# headless 옵션 설정options.add_argument('headless')options.add_argument(\"no-sandbox\")# 브라우저 윈도우 사이즈options.add_argument('window-size=1920x1080')# 사람처럼 보이게 하는 옵션들options.add_argument(\"disable-gpu\")   # 가속 사용 xoptions.add_argument(\"lang=ko_KR\")    # 가짜 플러그인 탑재options.add_argument('user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36')  # user-agent 이름 설정# 드라이버 위치 경로 입력driver = webdriver.Chrome('./chromedriver.exe', chrome_options=options)# url을 이용하여 브라우저로 접속driver.get('https://error.incites.thomsonreuters.com/error/Error?DestApp=IC2JCR&amp;Error=IPError&amp;Params=DestApp%3DIC2JCR&amp;RouterURL=https%3A%2F%2Flogin.incites.thomsonreuters.com%2F&amp;Domain=.thomsonreuters.com&amp;Src=IP&amp;Alias=IC2')driver.implicitly_wait(3)# 아이디/비밀번호를 입력해준다.driver.find_element_by_name('username').send_keys('아이디 입력')driver.find_element_by_name('password').send_keys('비밀번호 입력')# stay signed in 체크박스 채우기(클릭)driver.find_element_by_name('rememberme').click()# 로그인 버튼을 누르기driver.find_element_by_xpath('/html/body/div/div[1]/div[3]/div[1]/div/div/div/form/button').click()# 로그인 된 화면 캡처driver.get_screenshot_as_file('capture.png')driver.quit() 오른쪽 상단에 보면 아이디로 로그인 된 것을 확인 할 수 있다.   reference  https://beomi.github.io/2017/02/27/HowToMakeWebCrawler-With-Selenium/  https://wkdtjsgur100.github.io/selenium-xpath/",
        "url": "//python/crawler/2018/08/11/crawler-2.html"
      }
      ,
    
      "python-crawler-2018-08-11-crawler-1-html": {
        "title": "Python Selenium(셀레니움) 시작하기",
        "tags": "Selenium",
        "date": "August 11, 2018",
        "author": "",
        "category": "",
        "content": "연구실에서 갑자기 논문들에 대한 impactfactor 수집기를 만들게 되었다. 파이썬 웹크롤러를 만들 수 있는 아주 기본적인 패키지는 requests와 BeautifulSoup4 라는 패키지인데 사이트마다 request 방식이 get인지 post인지 구분해야하고 request를 보내도 작동이 안되는 페이지들이 있기 때문에 어려움이 살짝 있다. 일종의 무적 크롤러라고 불리는 selenium을 공부해보게 되었다! 맨 처음으로 셀레니움을 작동시키기 위한 셋팅 방법을 정리하였다.  1. selenium 이란?셀레니움의 원래 용도는 웹 테스트 자동화 프레임워크이다. selenium webdriver를 이용하여 다양한 브라우저를 조종할 수 있다. 셀레니움은 구글 크롬, 파이어폭스, 사파리, 마이크로소프트 엣지등의 브라우저를 조종할 수 있는 웹드라이버를 통하여 작동하기 때문에 웹 UI나 기능 테스트에 주로 사용한다. BeautifulSoup 같은 다른 웹 수집기도 있지만 이러한 수집기들은 Javascript로 실행하는 비동기적인 컨텐츠(뒤 늦게 불려와지는 컨텐츠)들은 수집하기 어려운 단점이 있다. 셀레니움을 크롤러로 사용했을 때 웹드라이버를 통하여 실제 사람이 사용하는 것과 비슷하게 작동하기 때문에 이미 페이지가 렌더링 된 상태에서 원하는 페이지의 html 파일을 수집할 수 있다. (html 파일에는 수집하고자 하는 다양한 정보들이 들어있다.)아직 많이 사용해 보지 않아서 정확한 단점은 알 수 없지만 처음 사용해 봤을 때 느낀점은 수집이 느리다는 단점이 있었다. 하지만 보이는 곳 어디든 수집이 가능하다는 장점이 있다.   2. selenium 설치셀레니움은 pip를 이용하여 간단하게 설치할 수 있다. 그리고 페이지를 랜더링 한 후 html을 파싱해올 때 BeutifulSoup4를 사용하므로 만약에 설치되어 있지 않다면 같이 설치해준다.$ pip install selenium$ pip install bs4   3. 크롬 브라우저 설치 및 크롬 웹드라이버 다운로드우선 셀레니움은 webdriver를 이용하여 작동하는데 기본적으로 많이 사용하는 크롬 웹드라이버를 사용하여 작동할 예정이다. 운영체제 환경마다 셋팅하는 방법이 조금씩 다르다. 연구실 컴퓨터는 윈도우(GUI가능), 노트북은 맥 OS(GUI가능), 연구실 서버는 Ubuntu16.04 LTS(GUI 불가능)를 사용하므로 세가지 운영체제에 대하여 정리하였다. 크롬 웹드라이버를 이용하므로 반드시 크롬 브라우저는 설치되어 있어야 한다!아래의 주소에서 크롬 드라이버를 다운로드 받을 수 있다(GUI 환경)  크롬 드라이버 다운로드 : https://sites.google.com/a/chromium.org/chromedriver/downloads위의 홈페이지 url로 접속해보면 이렇게 크롬 웹 드라이버를 받을 수 있는 화면이 나온다. 오른쪽 중간쯤에 Latest Release의 크롬 드라이버링크를 클릭한다.들어가보면 운영체제 별로 웹 드라이버를 다운로드 받을 수 있게 되어 있다.1) Windows 10 / MAC OS(GUI 가능)반드시 운영체제에 맞는 드라이버를 다운로드 받아야 한다. 웹 드라이버를 다운로드 받게되면 압축파일이 받아지게 되는데 압축을 풀고난 크롬드라이버를 파이썬 코드와 같은 경로에 두거나 경로를 기억해둔다. 나는 압축을 풀고 웹 드라이버 파일을 파이썬 코드 파일과 동일한 경로에 두었다.2) Ubuntu 16.04(GUI 불가능) + Docker 컨테이너 환경서버에서는 GUI가 안되고 파이썬 환경이 도커 컨테이너로 생성되어 있다. 따라서, CLI 환경에서 크롬 브라우저를 설치하여야 하고 크롬 웹드라이버도 다운로드 받아야 했다.도커 컨테이너 내에서는 sudo 명령어를 사용하지 않는다. 먼저 크롬 브라우저를 설치한다.# 크롬 apt-get에 추가$ wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub$ apt-key add -# apt-get 업데이트$ apt-get update# 크롬 브라우저 설치$ apt-get install google-chrome-stable그 다음 크롬 웹드라이버를 다운로드 받는다.# Downloads 폴더에 드라이버 다운로드$ wget -N http://chromedriver.storage.googleapis.com/2.10/chromedriver_linux64.zip -P ~/Downloads# 압축 풀기$ apt-get install unzip$ unzip ~/Downloads/chromedriver_linux64.zip# 프로젝트 폴더 안에 크롬 드라이버 넣어주기$ mv -f ~/Downloads/chromedriver 프로젝트 경로입력   4. selenium 코드 테스트 우분투 서버 환경에서는 GUI를 지원하지 않기 때문에 세 환경 모두 headless 버전으로 셀레니움 코드를 테스트 하였다. from selenium import webdriveroptions = webdriver.ChromeOptions()# headless 옵션 설정options.add_argument('headless')options.add_argument(\"no-sandbox\")# 브라우저 윈도우 사이즈options.add_argument('window-size=1920x1080')# 사람처럼 보이게 하는 옵션들options.add_argument(\"disable-gpu\")   # 가속 사용 xoptions.add_argument(\"lang=ko_KR\")    # 가짜 플러그인 탑재options.add_argument('user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36')  # user-agent 이름 설정# 드라이버 위치 경로 입력driver = webdriver.Chrome('./chromedriver.exe', chrome_options=options)driver.get('https://naver.com')driver.implicitly_wait(3)driver.get_screenshot_as_file('capture_naver.png')    # 화면캡처driver.quit() # driver 종료캡쳐화면을 확인해보면 아래와 같다.  reference  https://beomi.github.io/2017/02/27/HowToMakeWebCrawler-With-Selenium/  http://selenium-python.readthedocs.io/  http://ocsusu.tistory.com/61",
        "url": "//python/crawler/2018/08/11/crawler-1.html"
      }
      ,
    
      "python-django-development-20environment-docker-2018-08-09-django-docker-1-html": {
        "title": "Docker를 이용하여 Django 웹 데이터베이스 서버 셋팅",
        "tags": "Docker, Django",
        "date": "August 9, 2018",
        "author": "",
        "category": "",
        "content": "docker 컨테이너 연결을 하고 난 뒤 django 서버 셋팅하는 방법을 정리하였다. 데이터베이스 컨테이너와 웹서버 컨테이너를 연결하는 방법은 아래의 포스팅을 참고하면 될 것 같다.  도커 컨테이너 연결 : https://devyurim.github.io/ubuntu/docker/2018/06/27/ubuntu-docker-6.html도커 컨테이너 내에서 장고 서버를 구동하기 위한 셋팅 방법을 정리하였다. 장고 걸스 튜토리얼이 많은 도움이 되었다.   1. django 프로젝트 생성 장고 컨테이너 내부로 접속하여 장고 웹서버가 작동되는지 확인이 필요하다. 먼저 아래의 명령어를 실행하여 장고 프로젝트를 생성한다.$ django-admin startproject mysite .위의 명령어를 실행하여 생성되는 디렉터리 구조는 다음과 같다.                        ├──manage.py                         └──mysite         ├── init.py         ├── settings.py         ├── urls.py         └── wsgi.py 간단하게 역할들을 살펴보면 아래의 설명과 같다.  manage.py : 스크립트, 사이트 관리를 도와주는 역할, 스크립트 실행으로 웹서버를 실행할 수 있다.  mysite/settings.py : 웹사이트 설정 파일  mysite/urls.py : Django 로 작성된 사이트의 “목차”라고 할 수 있다.   mysite/wsgi.py : nginx나 apache를 연동하기 위한 interface  2. mysite/settings.py 파일 수정 그 다음 mysite/settings.py 파일을 수정해야한다. 에디터로 다음의 내용을 수정한다.먼저 시간, 호스트 접근권한을 변경하여 준다. TIME_ZONE='Asia/Seoul'ALLOWED_HOSTS = ['xxx.xxx.xxx.xxx(서버ip)','127.0.0.1', '.pythonanywhere.com']  #만약에 서버가 있다면 서버의 ip 주소도 추가해준다.LANGUAGE_CODE = 'en-us'       # 한국어로 바꾸고 싶다면 'ko-kr'로 변경 해주면 된다.그 다음 STATIC_URL밑에 STATIC_ROOT를 추가한다.STATIC_URL = '/static/'STATIC_ROOT = os.path.join(BASE_DIR, 'static')이렇게 수정한다음 저장하고 아래의 명령어로 migrate를 해준다.$ python manage.py migrate그 다음 장고 서버를 실행 한다.$ python manage.py runserver 0.0.0.0:8000다음과 같은 화면이 나오면 성공이다.  3. 데이터베이스 설정 변경 장고 서버에서 셋팅하기전 데이터 베이스 컨테이너와 link가 잘 되었는지 확인한다.$ mysql -h mariadb -u root -p0000잘 접속이 되면 이제 장고 컨테이너에 링크된 mariadb를 셋팅하면 된다. 장고 서버는 기본 데이터베이스가 sqlite3으로 설정되어 있다.나는 mariadb를 사용하길 원하므로 mysite/settings.py 에서 다음과 같이 장고 서버의 셋팅을 변경한다.DATABASES = {    'default': {        'ENGINE': 'django.db.backends.mysql',        'NAME': 'impactfactor',               # default로 사용하려는 데이터베이스 명        'USER':'root',                        # 유저 명        'PASSWORD':'0000',                    # 비밀번호        'HOST':'mariadb',                     # 호스트 명        'PORT':'',                            # 포트 번호 (default 3306)    }}migrate가 성공하고 난 뒤 다시 서버를 실행하면 정상적으로 실행되는 것을 확인 할 수 있다.$ python manage.py migrate$ python manage.py runserver 0.0.0.0:8000  4. django 어플리케이션 생성 데이터 베이스 화면을 보고싶다면 어플리케이션을 작성(데이터베이스 관련)하고 관리자 계정을 생성하여야 한다. 먼저 관리자 계정을 생성하려면 프로젝트 내부에 어플리케이션이 있어야 한다. manage.py가 있는 경로에서 다음의 명령어로 어플리케이션 폴더를 생성한다.$ python manage.py startapp show      # startapp 다음에 어플리케이션 이름을 입력한다.그럼 현재 디렉터리가 다음과 같을 것이다.├──manage.py ├──mysite  |        ├── init.py  |        ├── settings.py  |        ├── urls.py  |        ├── wsgi.py └── show          ├── migrations           |           └── init.py          ├── init.py          ├── admin.py          ├── models.py          ├── tests.py          └── views.py mysite/settings.py를 열고 다음의 항목에 어플리케이션(show)을 추가해준다.INSTALLED_APPS = [    'django.contrib.admin',    'django.contrib.auth',    'django.contrib.contenttypes',    'django.contrib.sessions',    'django.contrib.messages',    'django.contrib.staticfiles',    'show',]데이터베이스 테이블을 만들기 위해서 show/models.py 파일을 아래와 같이 수정한다.테이블명이 클래스명이 되며 클래스의 변수는 테이블의 각 컬럼이 된다.from django.db import modelsclass Journal(models.Model):    isbn = models.BigIntegerField(primary_key=True)    title = models.CharField(max_length=128)그 다음 show/admin.py 파일을 수정하여 관리자 페이지에 테이블이 나타나도록 수정한다.from django.contrib import adminfrom show.models import Journaladmin.site.register(Journal)그 다음 변경사항을 반영하기 위해 아래의 명령어를 실행한다.$ python manage.py makemigrations$ python manage.py migratemigrate를 하면 데이터베이스에 테이블이 만들어지면서 동기화가 된다. mysql 데이터베이스를 확인해보면 다음과 같다. 아래의 데이터베이스는 추가적으로 여러개의 모델을 생성하여 테이블을 여러개 생성한 결과이다.   5. django 관리자 계정 생성 이제 데이터 베이스에 관련된 셋팅은 다 되었고 최종적으로 확인하기 위하여 관리자 계정을 생성해야한다. 서버를 켜둔 상태로 다른 프롬프트 창을 열어 컨테이너에 재접속하여 아래의 명령어로 관리자 계정을 생성한다.$ python manage.py createsuperuserUsername (leave blank to use 'root'): # 관리자 계정명Email address: # 이메일Password: # 패스워드 입력Password (again): # 패스워드 확인호스트주소:포트/admin(ex. 127.0.0.1:8888/admin) 으로 접속하면 관리자 계정 로그인창이 뜬다. 방금 생성한 관리자 계정으로 로그인하면 접속이 되고 models.py에서 만들었던 테이블이 생성되 있는 것을 볼 수 있다.  reference  https://tutorial.djangogirls.org/ko  http://blog.daum.net/_blog/BlogTypeView.do?blogid=0QtKg&amp;articleno=28&amp;categoryId=0&amp;totalcnt=30",
        "url": "//python/django/development%20environment/docker/2018/08/09/django-docker-1.html"
      }
      ,
    
      "development-20environment-docker-2018-08-09-docker-2-html": {
        "title": "Docker 컨테이너 연결하기(Mariadb - Django/Python) - Ubuntu 16.04 LTS (Server)",
        "tags": "Docker, Django, Mariadb",
        "date": "August 9, 2018",
        "author": "",
        "category": "",
        "content": "연구실 서버에서 사용 할 데이터베이스를 docker를 이용하여 구축하였다. 연구실 서버가 외부에서도 사용가능 하니 로컬 데이터베이스가 아닌 서버 데이터베이스에 정보를 저장할 수 있도록 하기 위함이다.웹 프레임워크와 연동하여야 해서 조금 복잡하였다. 만드려는 컨테이너 구조는 아래의 그림과 같다.데이터 베이스 컨테이너와 웹서버 컨테이너가 연결되어 있는 구조이다. docker-compose는 사용하지 않고 웹서버 컨테이너 생성시 link 기능으로 연결해주었다.  1. Mariadb 도커 컨테이너 만들기데이터베이스 컨테이너를 생성 시 mariadb 이미지를 사용하였다.일단 아래의 명령어를 통해 docker hub에서 mariadb 이미지를 다운로드 받는다. 아래의 명령어는 태그명을 latest를 가지는 mariadb 이미지를 다운로드 받는 명령어이다. $ docker pull mariadb:latest다운로드 받은 이미지를 이용하여 데이터베이스 컨테이너를 생성(docker run)한다. 컨테이너가 삭제될 때 데이터가 날아가지 않도록 꼭 호스트의 데이터 볼륨과 연동해주어야 한다. 컨테이너를 생성하는 명령어는 다음과 같다.            옵션      기능                  –name      컨테이너 이름              -v      데이터 볼륨 맵핑(경로)              -p      포트 맵핑(호스트포트:서비스포트)              -e MYSQL_ROOT_PASSWORD      MYSQL ROOT 패스워드 설정              -d      사용하려는 이미지(이미지이름:태그명)      $ docker run --name mariadb \\-v /my/own/datadir:/home/ailab/DB \\-e MYSQL_ROOT_PASSWORD='0000' \\-d mariadb:latestmariadb 컨테이너 내부로 접속하여 데이터베이스가 잘 구동 되는지 확인한다. 컨테이너 내부로 접속하여 mysql을 실행하는 명령어는 다음과 같다.$ docker exec -it mariadb /bin/bash   // 도커 컨테이너 내부 접속$ mysql -p패스워드입력                // mysql 접속(유저 생성 안했을 시 root로 접속)추가적으로 mysql을 커맨드 라인으로 조작하는 명령어는 다음과 같다.$ show database;                    // 데이터베이스 보기$ use database이름;                 // 데이터베이스 선택$ show tabels;                      // 데이터베이스 내부 테이블 보기  2. Python 컨테이너 내부에서 django 설치 Django 이미지를 따로 사용하지 않고 기존에 사용하고 있던 Python/Tensorflow 개발용 컨테이너에 django를 설치하여 개발용 웹서버로 만들었다.기존에 사용하던 포트 이외 Django용 포트만 연결하여 주면 된다. 이 컨테이너에 데이터베이스 컨테이너를 연결해야하므로 link 명령어를 이용하여 데이터베이스를 연동하였다.먼저 텐서플로우 이미지를 이용하여 컨테이너를 생성하는 명령어는 아래와 같다.  텐서플로우 이미지 사용(주피터 노트북, 텐서플로우, 파이썬) / 8888 : 주피터 노트북 포트 , 8000 : 장고 포트, 3306 : 마리아 데이터베이스 포트)             옵션      기능                  NV_GPU      GPU 번호 지정              –name      컨테이너 이름              –link      연결할 컨테이너 이름(여기서는 mariadb 컨테이너)              -v      데이터 볼륨 맵핑(경로)              -p      포트 맵핑(호스트포트:서비스포트)              -e PASSWORD      host url로 접속시 패스워드 설정              -d      사용하려는 이미지(이미지이름:태그명)      $ NV_GPU=1 nvidia-docker run -it \\--name crawler-journal \\--link mariadb \\-v /home/ailab/docker/crawler-journal:/notebooks \\-p 8894:8888 -p 81:8000 -p 6012:3306  \\-e PASSWORD=\"\" \\-d crawler-journal:08.08방금 생성한 도커 컨테이너 내부로 접속하여 장고를 설치하는 명령어는 다음과 같다.$ docker exec -it crawler-journal /bin/bash   // 도커 컨테이너 내부 접속$ pip install django                          // 장고 설치  3. mariadb 컨테이너 연결 확인 현재의 컨테이너(웹 서버용)와 데이터베이스 컨테이너가 잘 연결(link) 되었는지 확인하기 위해서 몇가지 추가 작업이 필요하다. 먼저 웹 서버 컨테이너에서 mysql 서버에 접속하기 위해서는 apt-get으로 mysqlclient 패키지를 설치해준다.$ apt-get update$ apt-get install mysqlclient그다음 아래의 명령어로 mysql 서버에 접속한다. 이때 host는 mariadb(데이터베이스 컨테이너 이름)이고 계정은 따로 만들지 않았으니 root로 접속하고 패스워드(0000)를 입력해준다.$ mysql -h mariadb -u root -p0000데이터 베이스에 접속이 되면 컨테이너간 통신이 되는 것이다. 원래 호스트 주소 입력란에 127.0.0.1 같은 ip주소를 입력해야 하지만 docker 컨테이너의 ip는 도커가 할당해주는 가상 ip주소 이기 때문에 ip 주소가 변하게 된다.(고정 ip 주소가 아니다.) 그렇기 때문에 link 기능을 이용하여 도커 컨테이너 내부에서 알아서 호스트 주소를 받을 수 있게 하는것이 link 기능이라고 한다. 따라서 mysql -h 입력란에 컨테이너 이름을 입력하여도 연결이 가능한 것이다. 이렇게 해서 mariadb 컨테이너와 django/python 컨테이너가 연결이 되었다!  reference  https://www.fun25.co.kr/blog/python-install-mysqlclient/  https://wayhome25.github.io/mysql/2017/03/16/mysql-02-mysql-client/  http://pyrasis.com/book/DockerForTheReallyImpatient/Chapter06/02",
        "url": "//development%20environment/docker/2018/08/09/docker-2.html"
      }
      ,
    
      "development-20environment-git-2018-08-08-git-1-html": {
        "title": "Git 설치와 초기 설정 for Mac OS X",
        "tags": "Git",
        "date": "August 8, 2018",
        "author": "",
        "category": "",
        "content": "  1. Homebrew 이용하여 Git 설치Homebrew를 이용하여 git을 간단하게 설치 할 수 있다. 명령어는 아래와 같다. $ brew install git또는 직접 홈페이지에 가서 다운을 받아 설치하여도 된다.  Git 설치 : https://git-scm.com   2. Git 계정 설정로컬 디렉토리에서 git 저장소로 변경 push 하려면 github 계정명과 패스워드를 계속 입력해야하는 번거로움이 있다. 초기에 계정 설정을 한번만 해주면 (초기화 하지 않는 이상) 계속 유지되기 때문에 계정 설정을 해주는 것이 편리하다. 계정설정은 git config 라는 명령어로 실행할 수 있다. 명령어는 아래와 같다.$ git config --global user.name \"abcd\" // git user name$ git config --global user.email abcd@abcd // git user email프로젝트마다 다른 email을 사용하고 싶으면 --global 옵션을 제거하면 된다.git config 설정확인 명령어는 아래와 같다.$ git config --list  3. git에 SSH 공개키 등록 계정 정보를 입력하고 난 후 인증은 SSH 공개키로 인증해야 한다. 먼저 공개키가 있는지 확인한다.$ cat ~/.ssh/id_rsa.pub디렉터리가 없다고 뜨면 아래의 명령어로 공개키를 생성한다.$ ssh-keygen엔터 세번을 눌러 공개키를 만든다.(패스프레이즈 설정하지 않을 경우)다시 아래의 명령어로 공개키를 확인한다.$ cat ~/.ssh/id_rsa.pub나온 공개키를 github의 settings -&gt; SSH and GPG keys 카테고리를 클릭하고 오른쪽 부분의 new SSH key 버튼을 클릭하여 생성한 공개키를 등록한다.위의 이미지처럼 등록되면 성공!  reference  https://git-scm.com/book/ko/v2/GitHub-%EA%B3%84%EC%A0%95-%EB%A7%8C%EB%93%A4%EA%B3%A0-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0  https://git-scm.com/book/ko/v2/Git%EB%A7%9E%EC%B6%A4-Git-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0  https://git-scm.com/book/ko/v2/Git-%EC%84%9C%EB%B2%84-SSH-%EA%B3%B5%EA%B0%9C%ED%82%A4-%EB%A7%8C%EB%93%A4%EA%B8%B0",
        "url": "//development%20environment/git/2018/08/08/git-1.html"
      }
      ,
    
      "development-20environment-github-20blog-2018-08-07-blog-7-html": {
        "title": "Jekyll build 오류 해결 방법 - Windows 10",
        "tags": "Github Blog",
        "date": "August 7, 2018",
        "author": "",
        "category": "",
        "content": "&lt;p&gt;갑자기 윈도우에서 포스팅을 작성하고 확인하려고 jekyll build를 하였더니 아래의 오류가 발생하였다. &lt;/p&gt;PS C:\\Users\\user\\dropbox\\5. 블로그\\devYurim.github.io&gt; jekyll buildC:/Ruby24-x64/lib/ruby/gems/2.4.0/gems/bundler-1.16.3/lib/bundler/spec_set.rb:91:in `block in materialize': Could not find eventmachine-1.2.7-x64-mingw32 in any of the sources (Bundler::GemNotFound)        from C:/Ruby24-x64/lib/ruby/gems/2.4.0/gems/bundler-1.16.3/lib/bundler/spec_set.rb:85:in `map!'        from C:/Ruby24-x64/lib/ruby/gems/2.4.0/gems/bundler-1.16.3/lib/bundler/spec_set.rb:85:in `materialize'        from C:/Ruby24-x64/lib/ruby/gems/2.4.0/gems/bundler-1.16.3/lib/bundler/definition.rb:171:in `specs'        from C:/Ruby24-x64/lib/ruby/gems/2.4.0/gems/bundler-1.16.3/lib/bundler/definition.rb:238:in `specs_for'        from C:/Ruby24-x64/lib/ruby/gems/2.4.0/gems/bundler-1.16.3/lib/bundler/definition.rb:227:in `requested_specs'        from C:/Ruby24-x64/lib/ruby/gems/2.4.0/gems/bundler-1.16.3/lib/bundler/runtime.rb:108:in `block in definition_method'        from C:/Ruby24-x64/lib/ruby/gems/2.4.0/gems/bundler-1.16.3/lib/bundler/runtime.rb:20:in `setup'        from C:/Ruby24-x64/lib/ruby/gems/2.4.0/gems/bundler-1.16.3/lib/bundler.rb:107:in `setup'        from C:/Ruby24-x64/lib/ruby/gems/2.4.0/gems/jekyll-3.8.0/lib/jekyll/plugin_manager.rb:50:in `require_from_bundler'        from C:/Ruby24-x64/lib/ruby/gems/2.4.0/gems/jekyll-3.8.0/exe/jekyll:11:in `&lt;top (required)&gt;'        from C:/Ruby24-x64/bin/jekyll:23:in `load'        from C:/Ruby24-x64/bin/jekyll:23:in `&lt;main&gt;'구글에 검색하여 알아보았더니 bundle을 이용하여 gem버전을 업데이트 해줘야한다고 한다. 아래의 명령어로 해결하였다!$ bundle exec jekyll serveCould not find eventmachine-1.2.7-x64-mingw32 in any of the sourcesRun `bundle install` to install missing gems.PS C:\\Users\\user\\dropbox\\5. 블로그\\devYurim.github.io&gt; bundle installFetching gem metadata from https://rubygems.org/.............Using rake 10.5.0Using public_suffix 3.0.2Using addressable 2.5.2.....Using jekyll-category-pages 1.0.0Using jekyll-theme-type 1.1 from source at `.`Bundle complete! 3 Gemfile dependencies, 30 gems now installed.Use `bundle info [gemname]` to see where a bundled gem is installed.Post-install message from sass:Ruby Sass is deprecated and will be unmaintained as of 26 March 2019.* If you use Sass as a command-line tool, we recommend using Dart Sass, the new  primary implementation: https://sass-lang.com/install* If you use Sass as a plug-in for a Ruby web framework, we recommend using the  sassc gem: https://github.com/sass/sassc-ruby#readme* For more details, please refer to the Sass blog:  http://sass.logdown.com/posts/7081811다시 jekyll build를 실행하니 작동하였다.   reference   https://aisiunme.github.io/jekyll/2018/07/25/troubleshooting-in-jekyll-serve/",
        "url": "//development%20environment/github%20blog/2018/08/07/blog-7.html"
      }
      ,
    
      "development-20environment-github-20blog-2018-08-07-blog-6-html": {
        "title": "지킬(Jekyll) 블로그 카테고리(category) 만들기",
        "tags": "Github Blog",
        "date": "August 7, 2018",
        "author": "",
        "category": "",
        "content": "&lt;p&gt;포스트 개수가 많아지다 보니 관리가 힘들어서 카테고리를 만들었다. 카테고리 만든 방법을 간단하게 정리하였다.&lt;/p&gt;   1. _layouts 폴더에 category.html 파일 생성 먼저 _layouts 폴더에 category.html 파일을 생성해준다.category.html은 category 이름에 맞는 포스트들의 타이트들을 리스트로 보여준다. 코드는 아래와 같다.---layout: default---&lt;ul class=\"posts-list\"&gt;    {% assign category = page.category | default: page.title %}  {% for post in site.categories[category] %}    &lt;li&gt;      &lt;h3&gt;        &lt;a href=\"{{ site.baseurl }}{{ post.url }}\"&gt;          {{ post.title }}        &lt;/a&gt;        &lt;small&gt;{{ post.date | date_to_string }}&lt;/small&gt;      &lt;/h3&gt;    &lt;/li&gt;  {% endfor %}  &lt;/ul&gt;   2. _includes 폴더의 index.html 파일 수정아래의 내용과 같이 수정한다.&lt;header class=\"site-category\"&gt;  &lt;ul&gt;        {% assign pages_list = site.pages %}    {% for node in pages_list %}      {% if node.title != null %}        {% if node.layout == \"category\" %}          &lt;li&gt;&lt;a class=\"category-link {% if page.url == node.url %} active{% endif %}\"          href=\"{{ site.baseurl }}{{ node.url }}\"&gt;{{ node.title }}&lt;/a&gt;&lt;/li&gt;        {% endif %}      {% endif %}    {% endfor %}    &lt;/ul&gt;&lt;/header&gt;  3. category 폴더 생성 (맨 바깥의 디렉토리) 계정명.github.io 폴더 안에 category 폴더를 만들어준 다음 원하는 카테고리 명의 markdown 파일을 추가해준다. 마크다운 파일 내용은 아래와 같다.---layout: categorytitle: 여기에 카테고리 이름 입력!---예를들어, docker 카테고리를 만들고 싶다면 category 폴더의 docker.md의 내용은 다음과 같다.  4. 블로그 포스트에 category 추가하기위의 세가지 셋팅 후 포스트를 작성 시 카테고리 항목만 추가하여 주면 카테고리 지정이 된다.위의 이미지처럼 categories 항목을 추가해주고 원하는 카테고리 이름을 작성해주면 된다. (복수 카테고리도 가능하다.)주의 해야 할 점은 반드시! category 폴더에 원하는 category를 만들어주고 포스트에 같은 카테고리 명을 입력해야 한다.",
        "url": "//development%20environment/github%20blog/2018/08/07/blog-6.html"
      }
      ,
    
      "development-20environment-docker-2018-06-27-docker-1-html": {
        "title": "Docker를 이용하여 GitLab 설치하기 - Ubuntu 16.04 LTS (Server)",
        "tags": "Docker, GitLab",
        "date": "June 27, 2018",
        "author": "",
        "category": "",
        "content": "이제 연구실 서버 외부 접속이 가능해져서 코드 버전 관리를 위해 GitLab을 설치했다! 연구실 서버 환경은 우분투 16.04 LTS에 Docker를 사용하고 있다.GitLab 도커 이미지는 CE(Community Edition)과 EE(Enterprise Edition) 버전이 있는데 나는 CE 버전으로 설치하였다.  1. GitLab Docker 이미지 다운로드다음의 Docker 명령어를 통해서 gitlab 이미지를 Docker Hub에서 다운로드 받을 수 있다.latest의 태그명이 붙은 이미지를 다운로드 받았다.$ docker pull install gitlab/gitlab-ce:latest  2. gitlab 설치다음의 Docker 명령어로 GitLab 컨테이너를 생성한다.$ sudo docker run --detach \\    --hostname gitlab.ailab.com \\    --publish 8897:80 --publish 6015:22 \\    --name gitlab \\    --restart always \\    --volume /srv/gitlab/config:/home/ailab/GitLab \\    --volume /srv/gitlab/logs:/home/ailab/GitLab/log \\    --volume /srv/gitlab/data:/home/ailab/GitLab/data \\    gitlab/gitlab-ce:latest80번 포트는 http용 포트, 22번 포트는 ssh deamon용 포트이다. 도커 포트 맵핑은 호스트포트:컨테이너포트로 이루어지며나의 경우 publish 옵션을 보면 80번 컨테이너 포트는 호스트 포트 8897로, 22번 컨테이너 포트는 호스트 포트 6015 로 맵핑을 시켜두었다.즉, 웹에서 접근시 서버 주소:8897 로 접속할 수 있고 SSH로 GitLab 접속시 서버 주소와 ssh 6015 포트로 접속할 수 있다.데이터 저장 맵핑 설명은 다음을 참고하였다.참고로, 노출 host 포트는 다음과 같다고 문서에 적혀있다.  80 (http)  443 (if you configure HTTPS)  8080 (used by Unicorn)  22 (used by the SSH deamon)  3. Gitlab Configuration 수정외부에서 접속할 수 있도록 하기 위해서는 한가지 셋팅이 더 필요하다.먼저 아래의 Docker 명령어로 gitlab 이름의 컨테이너로 접속한다.$ docker exec -it gitlab /bin/bash다음 아래의 경로로 접속하여 nano 에디터로 gitlab.rb 파일을 수정한다.$ cd /etc/gitlab$ nano gitlab.rb파일에 들어가보면 화면 중간부분에 GitLab URL부분에 extenal_url 옵션의 주석을 해제하고 외부에서 접속 할 url을 입력해 준다.## GitLab URL##! URL on which GitLab will be reachable.##! For more details on configuring external_url see:##! https://docs.gitlab.com/omnibus/settings/configuration.html#configuring-the-external-url-for-gitlabexternal_url 'http://gitlab.ailab.com:8897'조금 내리다 보면 GitLab Shell setting for GitLab 부분에서 gitlab_rails['gitlab_shell_ssh_port'] 부분의 주석을 풀고 포트 부분을 수정해준다.### GitLab Shell settings for GitLabgitlab_rails['gitlab_shell_ssh_port'] = 6015# gitlab_rails['gitlab_shell_git_timeout'] = 800ctrl+o로 저장하고 enter를 누른후 ctrl+x로 나노 에디터를 빠져나온다.서버 주소:포트번호(xxx.xxx.xxx.xxx:8897)로 사이트를 접속하면 정상적으로 접속이 되는 것을 확인할 수 있다.root 계정이 사용할 비밀번호를 입력하고 id는 root 비밀번호는 방금 설정한 비밀번호로 sign in 하면 로그인이 되는 것을 확인 할 수 있다.또한 root 계정 이외에 개인 계정을 만들고 싶다면 register 부분에서 생성하면 사용할 수 있다이렇게 나의 소스코드를 안전하게 관리할 수 있는 개인 계정 서버가 생성되었다!  reference  https://docs.gitlab.com/omnibus/docker/",
        "url": "//development%20environment/docker/2018/06/27/docker-1.html"
      }
      ,
    
      "development-20environment-ubuntu-2018-05-29-ubuntu-4-html": {
        "title": "Windows와 Ubuntu간의 공유 폴더(Samba) 생성",
        "tags": "Ubuntu, Samba",
        "date": "May 29, 2018",
        "author": "",
        "category": "",
        "content": "연구실 개인 컴퓨터는 Windows이고 서버는 Ubuntu여서 외장하드를 이용해서 파일을 직접 옮기거나 Jupyter notebook을 이용해서 파일을 우분투로 옮기는 점이 불편해서 공유폴더(samba)를 하나 만들었다.   1. Samba 서버 설치일단 다음의 명령어로 samba를 설치한다.$ sudo apt-get install samba그 다음 아래의 명령어로 samba 계정을 추가하고 패스워드를 지정해준다. $ sudo smbpasswd -a ailab   2. samba 폴더 생성 및 config 수정samba 폴더를 만들 디렉터리로 이동 후 다음의 명령어로 samba 폴더를 생성한다.$ mkdir samba/etc/samba/smb.conf 를 열어 다음과 같이 편집한다.$ sudo nano /etc/samba/smb.conf# 파일을 열고 아래쪽으로 이동하여 [profiles] 밑에 다음과 같이 작성[ailab]                            # 네트워크에 보여질 공유 이름  comment = ailab share directory  # 디렉토리 설명  path = /home/ailab/samba         # 공유 디렉토리 절대 경로  valid users = ailab              # 접속을 허용할 계정  writeable = yes  create mask = 0664  directory mask = 0775ctrl + o, 엔터를 차례로 누른후 저장하고 ctrl+x 로 나온 다음 아래의 명령어로 samba 서버를 재시작 한다.$ sudo /etc/init.d/smbd restart     # samba server 재시작추가적으로 samba 서버 관련한 명령어는 다음과 같다.$ sudo service smbd start           # samba server 시작$ sudo service smbd stop            # samba server 멈춤$ sudo service smbd restart         # samba server 재시작(단, 권한 입력 필요)그리고 반드시!! 윈도우 탐색기에서 samba 서버에 접속하기 위해서 방화벽 139, 445 포트를 반드시 열어두어야 한다.$ sudo ufw allow 139      # 139 포트 개방$ sudo ufw allow 445      # 445 포트 개방   3. 윈도우 탐색기 연결하기제어판 -&gt; 사용자 계정 -&gt; 자격증명관리 -&gt; windows 자격 증명을 클릭한다.중간부분의 Windows 자격 증명 추가를 누른다.서버의 ip주소, 위에서 지정한 계정이름, 암호를 차례로 입력한다.[네트워크] 창에서 \\\\ip주소 를 입력하여 접속한다. 폴더를 바로가기에 등록해 두면 ip주소를 입력하지 않아도 접속 할 수 있다.   reference  http://w3devlabs.net/wp/?p=19940  https://blog.xianchoi.kr/145  https://m.blog.naver.com/PostView.nhn?blogId=kimmingul&amp;logNo=220639741333&amp;proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F",
        "url": "//development%20environment/ubuntu/2018/05/29/ubuntu-4.html"
      }
      ,
    
      "development-20environment-ubuntu-2018-05-28-ubuntu-3-html": {
        "title": "Multi-GPU 설치를 위한 NVIDIA 드라이버 재설치(업그레이드) - Ubuntu 16.04 LTS Server(Titan XP, Titan X)",
        "tags": "Ubuntu, NVIDIA",
        "date": "May 28, 2018",
        "author": "",
        "category": "",
        "content": "원래 연구실에 서버가 2대였는데 큰 서버가 하나 생겨서 원래 서버에서 쓰던 GPU를 옮겨 장착하게 되었다. 옮겨 장작했더니 Tensorflow를 실행할 때 오류가 발생하여 프로그램이 터져버렸다..ㅎㅎ 검색해보니 이러한 경우에는 GPU들의 드라이버 버전이 안맞아서 생기는 경우인것 같아 NVIDIA 드라이버를 재설치 하기로 하였다. 기존에 있던 GPU는 Titan Xp였고 새로 끼운 GPU는 GTX Titan X이다.   1. NVIDIA 드라이버 제거맨 처음 새로운 드라이버를 설치하기 위해 아래의 명령어로 설치되있던 NVIDIA 드라이버를 제거한다.$ sudo apt-get remove --purge nvidia-*지워보니 역시 드라이버가 충돌 했던것 같다.   2. NVIDIA 패키지 업데이트$ sudo apt-key adv --fetch-keys http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64/7fa2af80.pub$ sudo sh -c 'echo \"deb http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64 /\" &gt;&gt; /etc/apt/sources.list.d/cuda.list'$ sudo sh -c 'echo \"deb http://developer.download.nvidia.com/compute/machine-learning/repos/ubuntu1604/x86_64 /\" &gt;&gt; /etc/apt/sources.list.d/cuda.list'$ sudo apt-get update   3. 설치 할 NVIDIA 드라이버 버전 확인맨 처음 설치 법과 동일하게 아래의 NVIDIA 홈페이지에 가서 그래픽 카드 드라이버 버전을 확인한다.  http://www.nvidia.com/Download/Find.aspx?lang=en-us아래의 명령어를 통하여 설치 가능한 드라이버 버전을 확인한다.$ apt-cache search nvidia396은 베타버전이라서 390으로 설치하였다.$ sudo apt-get install nvidia-390설치후 드라이버가 적용 될 수 있도록 재부팅 해준다.   4. 드라이버 설치 확인아래의 명령어로 GPU 정보와 드라이버 설치를 확인한다.$ nvidia-smi아래와 같이 정보가 잘 뜨면 드라이버 설치 완료이다.   ** 확인 후 재설치 **  5. cuda, cudnn, nvidia-docker 확인일단 cuda, cudnn, nvidia-docker 존재 여부를 확인해본다.$ cat /usr/local/cuda/version.txt                                                   // cuda 설치 확인$ cat /usr/include/cudnn.h | grep -E \"CUDNN_MAJOR|CUDNN_MINOR|CUDNN_PATCHLEVEL\"     // cuDNN 설치 확인$ nvidia-docker run --rm nvidia/cuda nvidia-smi                                     // nvidia-docker 설치 확인일단 결과를 보니 nvidia-docker만 같이 지워진것 같다. nvidia-docker를 다시 설치 해 준다.$ sudo apt-get install nvidia-docker                          //nvidia-docker 재설치재부팅을 하고 아래의 명령어로 nvidia-docker 실행 여부를 확인한다.$ nvidia-docker run --rm nvidia/cuda nvidia-smi                //nvidia-docker 설치 확인[!!] 혹시 deamon 관련하여 오류가 났다면 아래의 링크의 포스팅에서 맨 밑에 해결방법을 적어 두었다.  https://devyurim.github.io/2018/05/25/17.html예시 코드를 실행해보니 AttributeError가 발생하였다. 기존의 컨테이너를 삭제하고 기존에 백업해두었던 이미지로 컨테이너를 재 생성해주니 잘 실행되었다.(nvidia-docker로 컨테이너 재생성) 나만의 문제일 수도 있다.   6. Tensorflow test code 실행Tensorflow 공식 문서를 참고하여 테스트를 진행하였다.import tensorflow as tf# Creates a graph.a = tf.constant([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], shape=[2, 3], name='a')b = tf.constant([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], shape=[3, 2], name='b')c = tf.matmul(a, b)# Creates a session with log_device_placement set to True.sess = tf.Session(config=tf.ConfigProto(log_device_placement=True))# Runs the op.print(sess.run(c))gpu를 모두 인식하고 잘 계산이 되었다!아래의 multi-gpu버전 코드를 이용하여 gpu를 지정하여 계산을 실행해 보았다.import tensorflow as tf# Creates a graph.c = []for d in ['/device:GPU:0', '/device:GPU:1']:  with tf.device(d):    a = tf.constant([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], shape=[2, 3])    b = tf.constant([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], shape=[3, 2])    c.append(tf.matmul(a, b))with tf.device('/cpu:0'):  sum = tf.add_n(c)# Creates a session with log_device_placement set to True.sess = tf.Session(config=tf.ConfigProto(log_device_placement=True))# Runs the op.print(sess.run(sum))짠! 성공적이다!   reference  https://devyurim.github.io/2018/05/25/17.html  https://devyurim.github.io/2018/05/24/15.html  http://limit0.tistory.com/entry/Ubuntu-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-Nvidia-GPU-%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B2%84-%EC%84%A4%EC%B9%98-%EB%B0%A9%EB%B2%95%EC%99%84%EA%B2%B0  https://www.tensorflow.org/programmers_guide/using_gpu",
        "url": "//development%20environment/ubuntu/2018/05/28/ubuntu-3.html"
      }
      ,
    
      "python-tensorflow-development-20enviroment-docker-2018-05-25-tensorflow-3-html": {
        "title": "도커(Docker)를 이용하여 텐서플로우(Tensorflow) GPU 버전 설치하기 - Ubuntu 16.04(Titan XP)",
        "tags": "Tensorflow, Docker",
        "date": "May 25, 2018",
        "author": "",
        "category": "",
        "content": "나의 험난했던… 연구실 서버 셋팅기를 글로 남겨보려고 한다..! 연구실 서버의 사양은 Ubuntu 16.04 / Titan XP 이다. 여러명이서 같이 써야하기 때문에 docker로 텐서플로우 GPU 버전을 사용할 수 있는 환경을 구성하였다.   1. Docker 설치 및 셋팅      도커(Docker)    설치 : 서버 운영체제는 우분투 16.04 LTS 를 사용하고 있고 아래의 명령어를 이용하여 자동 스크립트로 도커를 설치 하였다.  $ curl -fsSL https://get.docker.com/ | sudo sh  sudo 없이 사용하기 : docker는 기본적으로 root권한이 필요한데, root가 아닌 사용자가 sudo없이 사용하려면 사용자를 docker 그룹에 추가해 주면 된다.$ sudo usermod -aG docker $USER           // 현재 접속중인 사용자에게 권한주기$ sudo usermod -aG docker ailab           // 'ailab' 사용자에게 권한주기  도커(Docker) 버전 확인 : 버전을 확인하여 설치가 되었는지 확인한다.$ docker version   2. NVIDIA-docker 설치도커 컨테이너가 NVIDIA GPU를 support하려면 이미지를 실행할 때 nvidia-docker로 반드시 실행을 해야한다. 설치방법은 아래의 github에 자세히 명시되어 있다. 현재는 nvidia-docker가 2.0 버전이지만, 2.0 버전을 설치하고 실행했을때 명령어를 실행할 수 없어서 1.0으로 설치 하였다.. 2.0으로 설치했을때 docker 실행이 왜 안되는지는 나도 모르겠다 ㅠ.ㅠ..  nvidia-docker : https://github.com/NVIDIA/nvidia-docker  nvidia-docker 1.0 설치 공식문서 : https://github.com/NVIDIA/nvidia-docker/wiki/Installation-(version-1.0)다음의 명령어로 nvidia-docker 1.0 을 설치해준다.$ sudo apt-get install nvidia-docker다음의 명령어로 nvidia-docker 명령어가 제대로 실행되는지 확인해준다.(자동으로 CUDA 이미지가 다운로드 받아지는데 나중에 지워도 무방하다.)$ nvidia-docker run --rm nvidia/cuda nvidia-smi아래의 이미지와 같이 GPU 정보가 뜨면 설치 완료이다!   2. NVIDIA 드라이브, CUDA, cuDNN 설치 확인Tensorflow GPU 버전을 설치하려면 반드시 CUDA와 cuDNN이 설치되어 있어야 한다. 또한, CUDA를 설치하기 위해서는 NVIDIA 드라이버가 설치되어 있어야한다. 자세한 설치 내용은 아래의 블로그 포스팅을 참조하길 바란다.  NVIDIA 드라이버 설치 : https://devyurim.github.io/2018/05/24/15.html  CUDA 9.0, cuDNN 7.0 설치 : https://devyurim.github.io/2018/05/25/16.html$ cat /usr/local/cuda/version.txt                                                   // cuda 설치 확인$ cat /usr/include/cudnn.h | grep -E \"CUDNN_MAJOR|CUDNN_MINOR|CUDNN_PATCHLEVEL\"     // cuDNN 설치 확인   3. Tensorflow Docker 설치도커(Docker)는 이미지(image)파일을 이용하여 개발 환경을 운영할 수 있다. 텐서플로우에서 공식적으로 제공하는 텐서플로우 도커를 다운로드 받을 수 있다.우선 공식 무료 배포 이미지들을 다운로드 받으려면 docker hub 홈페이지에 가입이 필요하다.  DockerHub : https://hub.docker.com/그리고 터미널에서 아래의 명령어를 이용하여 docker hub에 로그인해준다.$ docker login아이디와 비밀번호를 입력하고 엔터를 누르면 Login Succeeded가 뜨면 docker hub에 접속할 수 있는 권한을 얻은 것이다.  docker hub에서 tensorflow 이미지 검색docker hub에서 tensorflow 로 검색하여 tag버튼 을 누르면 아래와 같이 다운로드 받을 수 있는 태그 목록을 확인 할 수 있다. tensorflow docker image 파일 태그 예시나는 Tensorflow 1.8.0 gpu버전 python3을 사용하길 원하기 때문에 아래의 명령어를 이용하여 텐서플로우 이미지를 다운로드 받았다. 자세한 사항은 아래의 사이트 참고  tensorflow docker hub : https://hub.docker.com/r/tensorflow/tensorflow/$ docker pull tensorflow/tensorflow:1.8.0-gpu-py3       // 태그명이 1.8.0-gpu-py3인 텐서플로우 이미지 다운로드$ docker images                                         // 도커 내 이미지 확인 명령어이미지를 다운 로드 받았으면 nvidia-docker를 이용하여 컨테이너를 생성하면된다. docker에서 컨테이너를 생성하는 명령어는 run이다. 내가 사용한 옵션은 다음과 같다.$ nvidia-docker run -it \\-p 8891:8888 -p 6006:6006--name ailab-yurim-v /home/ailab/docker/ailab-yurim:/notebooks \\-e PASSWORD=\"0000\" \\--restart always \\tensorflow/tensorflow:1.8.0-gpu-py3  옵션 추가 설명 -p : 포트 번호 입력 (호스트 포트번호 : 컨테이너 포트번호)    옵션에서 포트번호를 2개를 해준 이유는 8888은 Jupyter notebook 연결 포트이고 6006은 Tensorboard 연결 포트이다.    6006을 연결 안해주면 Tensorboard가 실행이 안되므로 포트를 꼭 맵핑해주어야 한다!!–name : 생성할 컨테이너 이름 -v : 컨테이너와 맵핑할 폴더의 경로 + Jupyter notebook 설정 -e : 컨테이너 접속 비밀번호 –restart always : 도커 데몬이 실행됬을때 컨테이너 자동으로 실행(run) tensorflow:1.8.0-gpu-py3 : 실행할 이미지를 '이미지명:태그명' 으로 입력 Jupyter notebook 접속시 localhost라면 http://localhost:8888 로 접속하면 되고, 따로 ip주소가 설정되있다면 http://ip주소:호스트포트번호 로 접속하면 된다. Tensorboard도 마찬가지 이다.  [!!!] 우분투 도커 데몬 실행 안될때컴퓨터를 재부팅하고 docker를 재부팅 하였을때 아래와 같은 이미지의 오류와 docker deamon을 실행할 수 없다는 오류가 발생하였다. 이 문제는 nvidia-docker로 컨테이너를 생성하였을 때 발생하는 nvidia-container-runtime 문제로 docker engine에 nvidia-runtime을 등록해주어야 한다고 한다. github 홈페이지를 보고 아래의 명령어를 터미널에 붙여 넣어 docker engine을 다시 설정하여 문제를 해결하였다.  nvidia-container-runtime : https://github.com/NVIDIA/nvidia-container-runtimesudo mkdir -p /etc/systemd/system/docker.service.dsudo tee /etc/systemd/system/docker.service.d/override.conf &lt;&lt; EOF [서비스]ExecStart =ExecStart = / usr / bin / dockerd --host = fd : // --add-runtime = nvidia = / usr / bin / nvidia-container-runtimeEOFsudo systemctl daemon-reloadsudo systemctl restart docker   conference  https://subicura.com/2017/01/19/docker-guide-for-beginners-2.html  https://sehoi.github.io/2017-01-06/docker-basic/  https://www.tensorflow.org/install/install_linux#InstallingDocker  https://github.com/NVIDIA/nvidia-docker/wiki/Installation-(version-1.0)  https://github.com/NVIDIA/nvidia-container-runtime",
        "url": "//python/tensorflow/development%20enviroment/docker/2018/05/25/tensorflow-3.html"
      }
      ,
    
      "python-tensorflow-2018-05-25-tensorflow-2-html": {
        "title": "텐서플로우(Tensorflow) 설치를 위한 CUDA / cuDNN 설치 - Ubuntu 16.04 LTS Server(Titan XP)",
        "tags": "Tensorflow",
        "date": "May 25, 2018",
        "author": "",
        "category": "",
        "content": "서버 사양은  Ubuntu 16.04 / titan XP  이고, 설치할 버전은  CUDA 9.0 / cuDNN 7.0  이다.   1. NVIDIA 드라이버 설치 확인 및 Compute Capability 확인아래의 명령어를 통해 드라이버 설치와 그래픽카드를 확인 할 수 있다.$ nvidia-smiCUDA 설치 이전에 GPU의 Compute Capability를 지원하는 지 확인하여야 한다. Compute Capability에 따라 설치 할 수 있는 CUDA 버전은 NVIDIA 홈페이지에서 확인이 가능하다.  NVIDIA 홈페이지 : https://developer.nvidia.com/cuda-gpusNVIDIA 홈페이지  - CUDA-Enabled GeForce Products 발췌CUDA 9.0 버전은 Compute capability 3.0~7.x 까지 지원한다.   2. 패키지 리스트 추가아래의 명령어로 패키지 소스 리스트를 추가하고 업데이트 한다.$ sudo apt-get update &amp;&amp; sudo apt-get install sudo gnupg$ sudo apt-key adv --fetch-keys http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64/7fa2af80.pub$ sudo sh -c 'echo \"deb http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64 /\" &gt;&gt; /etc/apt/sources.list.d/cuda.list'$ sudo sh -c 'echo \"deb http://developer.download.nvidia.com/compute/machine-learning/repos/ubuntu1604/x86_64 /\" &gt;&gt; /etc/apt/sources.list.d/cuda.list'$ cat /etc/apt/sources.list.d/cuda.list$ sudo apt-get update아래의 CUDA와 cuDNN의 버전은 텐서플로우 홈페이지를 참고하여 설치하였다.   3. CUDA 9.0 설치아래의 명령어를 이용하여 CUDA 9.0을 설치한다.$ sudo apt-get install cuda-9-0   4. cuDNN 7.0 설치아래의 명령어를 이용하여 cuDNN 7.0을 설치한다.$ sudo apt-get install libcudnn7-dev   5. 버전 확인  CUDA 설치 확인$ cat /usr/local/cuda/version.txt  cuDNN 설치 확인$ cat /usr/include/cudnn.h | grep -E \"CUDNN_MAJOR|CUDNN_MINOR|CUDNN_PATCHLEVEL\"   refernece  https://hiseon.me/2018/03/11/cuda-install/  https://developer.nvidia.com/cuda-gpus  https://www.tensorflow.org/install/install_linux#InstallingAnaconda",
        "url": "//python/tensorflow/2018/05/25/tensorflow-2.html"
      }
      ,
    
      "development-20environment-ubuntu-2018-05-24-ubuntu-2-html": {
        "title": "서버에 NVIDIA 드라이버 설치하기 - Ubuntu 16.04 LTS Server(Titan XP)",
        "tags": "Ubuntu, NVIDIA",
        "date": "May 24, 2018",
        "author": "",
        "category": "",
        "content": "서버 사양은 Ubuntu 16.04 LTS/ titan XP 이다.   1.우분투 패키지 업데이트$ sudo apt-get update$ sudo apt-get upgrade   2.NVIDIA 드라이버 설치 확인 및 GPU 모델 정보 확인다음의 명령어를 이용하여 NVIDIA 드라이버가 설치되어 있는지 확인한다.$ cat /proc/driver/nvidia/version다음과 같이 디렉토리가 없다고 뜨면 드라이버가 설치되지 않은 것이다.그다음 언어 설정이 되지 않았을 경우 설치에 필요한 언어셋등의 기본패키지를 설치해준다.$ apt-get update &amp;&amp; apt-get install -y dialog language-pack-en$ export LANGUAGE=en_US$ export LANG=en_US.UTF-8$ export LC_ALL=en_US.UTF-8$ sudo update-locale그 다음 아래의 내용을 /etc/default/locale에 추가해준다.(nano 에디터 사용, ctrl + o -&gt; enter로 저장)$ sudo nano /etc/default/locale# 아래의 정보 추가LANG=\"en_US.UTF-8\"LANGUAGE=\"en_US:en\"LC_ALL=\"en_US.UTF-8\"   3.Ubuntu NIVIDA Repository 업데이트NVIDIA 드라이버를 설치하기 전에 먼저 우분투 버전을 확인한다. $ cat /etc/issue우분투 16.04는 NVIDIA Repository가 지원이 되므로 아래의 명령어를 통해 최신 NVIDIA 패키지 리스트를 추가한다.$ sudo apt-key adv --fetch-keys http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64/7fa2af80.pub$ sudo sh -c 'echo \"deb http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64 /\" &gt;&gt; /etc/apt/sources.list.d/cuda.list'$ sudo sh -c 'echo \"deb http://developer.download.nvidia.com/compute/machine-learning/repos/ubuntu1604/x86_64 /\" &gt;&gt; /etc/apt/sources.list.d/cuda.list'$ sudo apt-get update   4.NVIDIA 그래픽카드 드라이버 설치아래의 NVIDIA 홈페이지에 가서 그래픽 카드 드라이버 버전을 확인한다.  http://www.nvidia.com/Download/Find.aspx?lang=en-us본인의 사양에 맞게 설정하고 Search 클릭하여 확인한다.아래의 명령어를 통하여 설치가능한 드라이버 버전을 확인한다. nvidia-xxx로 나타나는 패키지 이름 중에서 설치 가능한 버전을 확인하면 된다.$ apt-cache search nvidia위의 홈페이지에서 조회되는 버전은 381버전 부터 390버전이므로 apt-cache로 확인해 보았을때 최상위 버전은 384 버전이다. 아래의 명령어로 설치한다.$ sudo apt-get install nvidia-384설치후 드라이버가 적용 될 수 있도록 reboot 한다.   5.확인설치가 성공적으로 되었는지 확인하기 위해서 아래의 명령어를 실행한다.$ lspci -k아래의 명령어를 이용하면 드라이버 버전을 확인 할 수 있다.$ cat /proc/driver/nvidia/version아래의 명령어를 이용하면 그래픽 카드 정보를 확인 할 수 있다.$ nvidia-smi  reference  https://hiseon.me/2018/02/17/install_nvidia_driver/",
        "url": "//development%20environment/ubuntu/2018/05/24/ubuntu-2.html"
      }
      ,
    
      "development-20environment-ubuntu-2018-05-02-ubuntu-1-html": {
        "title": "우분투(Ubuntu) USB 부팅디스크 만들기 - Windows 10",
        "tags": "Ubuntu",
        "date": "May 2, 2018",
        "author": "",
        "category": "",
        "content": "  1. 우분투(Ubuntu) 다운로드먼저 우분투(Ubuntu) 홈페이지에 가서 Ubuntu iso 파일을 다운로드 한다.  우분투(Ubuntu) 다운로드 : https://www.ubuntu.com/download/desktop  2. Universal USB Installer 다운로드USB 부팅 디스크를 만들려면 Universal USB Installer라는 프로그램이 필요하다. 아래의 사이트에서 다운로드 받아 준다.  Universal USB Installer : https://universal-usb-installer.kr.uptodown.com/windows프로그램을 다운로드 받고 실행한다.I Agree를 클릭한다Step1에서 Ubuntu를 선택한다Step2에서 browse 버튼을 클릭해 다운로드 받은 Ubuntu iso 파일의 경로를 설정한다.포맷된 USB를 컴퓨터에 연결하고 Step3에서 부팅디스크를 만들 USB를 선택한다.Step1,2,3을 다 설정했으면 Create 버튼을 누른다.다음 창이 나오면 예(Y) 버튼을 눌러 부팅디스크를 만든다.Universal USB Installer를 이용하여 윈도우에서 간단하게 Ubuntu 부팅 디스크를 만들 수 있다.   reference  https://tutorials.ubuntu.com/tutorial/tutorial-create-a-usb-stick-on-ubuntu?_ga=2.66069614.1720290893.1525243898-1690874967.1525243898#0  http://physics2.mju.ac.kr/juhapruwp/?p=1135",
        "url": "//development%20environment/ubuntu/2018/05/02/ubuntu-1.html"
      }
      ,
    
      "development-20environment-java-2018-05-02-java-1-html": {
        "title": "Java JDK 설치하기 - Windows 10 / MAC OS",
        "tags": "Java",
        "date": "May 2, 2018",
        "author": "",
        "category": "",
        "content": "간단하게 JAVA JDK 설치와 환경변수 편집에 관련한 내용을 글로 남기려고 작성하였다.  1. JDK 다운로드 받기Java 프로그래밍을 하려면 JDK(Java Development Kit, 자바 개발 키트)와 JRE(Java Runtime Environment, 자바 실행 환경) 라는 것이 있어야 한다.JRE는 JVM(Java Virtual Machine, 자바 가상 머신)위에서 자파 프로그램을 실행시키기 위해서 필요한 라이브러리들을 가지고 있으며, JDK는 JRE를 포함하고 개발을 위해 필요한 도구(javac, java)등을 포함하고 있다. JDK를 설치하면 JRE는 같이 설치되기 때문에 따로 JRE를 받을 필요는 없다. JDK는 오라클(Oracle) 사이트에서 받을 수 있다.  JDK 다운로드http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html?ssSourceSiteId=otnptAccept License Agreement 의 오디오 박스에 체크를 하고 자신의 OS에 맞는 것을 다운로드 하고 설치를 진행하면 된다.  2. JDK 환경변수 설정1) Windows에서 JDK 환경 변수 설정   윈도우 검색 창에 시스템 환경변수 편집 검색 -&gt; 시스템 속성 -&gt; 고급 -&gt; 환경변수   환경변수 창에서 시스템변수 새로만들기 클릭   JAVA_HOME 변수 추가 : 변수값에는 jdk를 설치한 경로를 입력하면 된다.  시스템변수 path 선택 -&gt; 편집 -&gt; 새로만들기 -&gt; JAVA_HOME 경로 추가   모두 확인 눌러서 나오기   Windows Powershell에서 JAVA 버전 확인  $java -version 2) MAC OS 에서 JDK 환경 변수 설정   JAVA 디렉토리로 이동 $cd /Library/Java/JavaVirtualMachines   ls를 이용하여 JDK 버전 확인  home 파일로 접속 $cd /Library/Java/JavaVirtualMachines/jdk버전.jdk/Contents/Home   vim 에디터 이용하여 bash_profile 접근  $vi ~/.bash_profile   수정모드에서 경로 추가  export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk버전.jdk/Contents/Home   esc 누른 후, :wq로 저장하고 수정모드를 빠져나온다.   터미널에서 JAVA 버전 확인  $java -version   reference  https://wikidocs.net/257  http://prolite.tistory.com/975",
        "url": "//development%20environment/java/2018/05/02/java-1.html"
      }
      ,
    
      "python-tensorflow-2018-04-30-tensorflow-1-html": {
        "title": "텐서플로우(Tensorflow) GPU 버전 설치하기 - Windows 10",
        "tags": "Tensorflow",
        "date": "April 30, 2018",
        "author": "",
        "category": "",
        "content": "연구실 내 컴퓨터에 드디어 GPU가..!! 로컬에서 Tensorflow GPU를 사용하기 위해 험난했던 GPU 버전 설치 방법을 남긴다…반드시 tensorflow 공식 문서를 확인해야한다!!!추천 cuda버전, cudnn버전, anaconda일때 파이썬 몇 버전 써야하는지, native pip 일때 파이썬 몇 버전을 써야하는지 적혀있다. 자신의 환경에 맞춰서 공식문서를 보고 파이썬 버전을 잘 선택해야한다. 또한, 선택하는 운영체제에 따라서도 버전이 다르다. 나는 Windows 10 / Anaconda 를 사용하여 설치할 예정이다.  Tensorflow 공식 홈페이지 : https://www.tensorflow.org/   1. CUDA Toolkit 설치 텐서플로우 홈페이지에가서 install 버튼을 눌러보면 친절하게 NVIDIA CUDA xx 설치하세요 라고 나와있다.나는 여기에 맞춰서 CUDA 9.0 버전을 설치하였다. 현재는 배포하는 버전은 9.1 버전이여서 CUDA Toolkit Archive에 가서 CUDA 9.0을 받았다.  NVIDIA Cuda Toolkit 설치 : https://developer.nvidia.com/cuda-toolkit-archive설치가 완료 되고 재부팅한다음에 환경변수 가 제대로 설치 되었나 확인해야한다.  시스템 환경변수 편집 -&gt; 고급 -&gt; 환경변수 클릭위와 같이 CUDA_PATH 가 추가되어있으면 OK이다!만약에 CUDA버전을 여러개 설치한다면 CUDA_PATH_V9_0과 같이 구분되며 최근 설치한 버전이 CUDA_PATH로 들어간다고 한다.   2. cuDNN 다운로드 이것도 역시 텐서플로우 홈페이지에 명시되어 있다. cuDNN은 7.0.x버전 으로 다운로드 받았다. cuDNN을 받으려면 DEVELOPER 홈페이지에 가입이 필요하다. 먼저 가입을 하고 다운로드 받는다.  cuDNN 다운로드 : https://developer.nvidia.com/rdp/cudnn-archiveCUDA 버전에 유념해서 다운로드 받아야한다. 나는 cuDNN v7.0.5 for CUDA 9.0 을 받았다.압축파일을 압축 해제후 cuda 폴더 에 들어가보면 다음과 같은 3개 의 파일이 있다.이 세개 파일을 모두 CUDA_PATH 경로의 폴더에 추가해준다. CUDA_PATH 경로는 시스템 환경변수에 가면 확인 할 수 있다. 나는 아래와 같다.C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.0즉, cuda 폴더 안의 내용을 CUDA_PATH 경로에 ctrl+c / ctrl+v 해서 복사 하면 완료!   3. Anaconda를 이용해 Tensorflow 설치 나는 아나콘다(Anaconda)가 이미 설치되어 있는 상태이기 때문에 아나콘다를 이용하여 설치하였다. 아나콘다가 없다면 아나콘다를 설치하거나 python3.5버전(홈페이지에서 운영체제 별로 지원하는 파이썬 버전으로 설치 할 것)을 설치하면된다.일단 현재 버전의 아나콘다는 python3.6을 기준으로하기 때문에 python3.5 버전을 가진 새로운 아나콘다 환경을 만들어 주어야 한다.아직 python 3.6은 지원하지 않는 것으로 보이므로(2018.8.29 기준으로 지원) 반드시!! python3.5 버전 으로 환경설정을 해주어야 한다.일단 윈도우 검색창에 Anaconda를 검색하여 Anaconda Prompt 를 켠다. 나는 환경이름을 cuda로 설정했다.환경활성화는 Windows Powershell에서는 안되고 conda prompt에서만 가능하다!conda create -n cuda pip python=3.5 /*환경 만들기(python 3.5) -&gt; y/n 나오면 y 누를것.*/activate cuda  /*환경 활성화*/activate 하였을 때 다음과 같이 (cuda) 로 변경되어야 한다. 다음 아래의 명령어를 실행하여 Tensorflow GPU 버전 을 설치한다.python -m pip install --upgrade pip /*일단 pip 를 업그레이드 시켜준다.*/pip install --ignore-installed --upgrade tensorflow-gpu /*텐서플로우 GPU 버전 설치*/Tesorflow CPU 버전은 아래와 같은 명령어로 설치하면 된다.pip install --ignore-installed --upgrade tensorflow설치가 끝나면 jupyter notebook도 설치하고 jupyter notebook을 켜서 코드가 잘 돌아가는지 확인한다.위에 처럼 예시 코드가 잘 돌아가면 GPU 버전 설치 완료!!아래의 명령어들은 참고 명령어 사항이다.conda info --envs /*아나콘다 환경 확인하기*/conda remove --name 삭제하려는환경이름 --all /*아나콘다 환경 삭제하기*/위와 같이 모든 아나콘다 환경이 표시가 된다. 내가 현재 사용하고 있는 환경은 * 로 표시된다.아나콘다 환경 활성화/비활성화는 아래와 같은 명령어로 실행 할 수 있다.activate cuda /*cuda라는 이름을 가진 아나콘다 환경 활성화*/deactivate cuda /*cuda라는 이름을 가진 아나콘다 환경 비 활성화*/  Reference      https://www.tensorflow.org/install/install_windows    http://solarisailab.com/archives/1581    http://hiuaa.tistory.com/39    http://dwfox.tistory.com/85  ",
        "url": "//python/tensorflow/2018/04/30/tensorflow-1.html"
      }
      ,
    
      "data-20science-machine-20learning-2018-04-13-ml-1-html": {
        "title": "Machine Learning(머신러닝) 시작하기",
        "tags": "Machine Learning",
        "date": "April 13, 2018",
        "author": "",
        "category": "",
        "content": "이번 학기를 끝으로 학부생은 끝나고 다음학기 부터 석사를 시작할 예정이다.연구실에 일한지 어느덧 2년정도 되어 몇몇 알고리즘을 사용도 해보고 실제 서비스에 적용도 해보았지만, 아직도 머신러닝의 개념이 명확하지 않은 느낌이 들었다.또한, 앞으로 석사 때 딥러닝을 공부할 예정이기 때문에 딥러닝에 대하여 심도 있게 연구하기 위해서는 머신러닝의 개념들이 뒷받침 되어야 한다고 생각했다.석사로 입학하여 연구를 시작하기에 앞서 머신러닝의 베이직한 개념부터 다양한 머신러닝 알고리즘을 앞으로 꾸준히 정리해 나갈 예정이다.  1. Supervised Learning(지도 학습)지도학습(Supervised Learning)은 학습할 때 데이터에 대한 정답 라벨(Label) 을 이용하여 정답 값을 구하기 위한 함수 를 유추하는 학습방법이다.  지도 학습시 데이터를 트레이닝을 위한 데이터셋(training data-set) 과 테스트를 위한 테스트 데이터셋(test data-set) 으로 나누어 진행을 하여야한다.  머신러닝 알고리즘을 학습할 때는 트레이닝 데이터 셋(training data-set) 을 이용하여 학습 을 하고 테스트 데이터 셋(test data-set) 으로 성능을 측정 한다.  지도 학습(Supervised Learning)은 데이터가 많으면 많을수록 정답 데이터를 만드는데 시간과 비용이 많이 소모된다는 단점이 있지만,  쉽게 머신러닝 알고리즘에 적용이 가능하고 성능 측정 방법이 쉽다는 장점이 있다.지도 학습을 사용하는 문제에는 다음과 같은 것들이 있다. 1) 분류(Classification)데이터와 카테고리 간의 관계를 학습하여 데이터의 카테고리를 판별하는 방법이다. 카테고리는 클래스(class) 라고 불린다.  예측 하려는 값이 이산 값(discrete value)일 때 사용하는 방법이다.ex) 이미지의 카테고리 예측하기, 스팸 / 비스팸 이메일 구분하기 등 http://cs231n.github.io/classification/2) 회귀(Regression)위의 분류(Classification) 가 데이터 셋트에 대하여 어떠한 특정 클래스를 찾는 문제였다면, 회귀(Regression) 는 어떤 X값 에 대하여 Y값 의 정답을 만족할 수 있는 최선의 방정식(equation) 을 찾는 것이다. 예측하려는 값이 연속된 값(continuous value)일 때 사용하는 방법이다.  이때 성능 측정은 내가 예측한 y’ 값과 정답 y 값의 차이를 비교하는 방법으로 RMSE(평균 제곱근 오차, Root Mean Square Error)를 낮추는 것을 목표로 한다.ex) 학생의 점수 분포를 이용하여 예상 점수 예측하기, 부동산 가격 예측, 주가 예측 등   2. Unsupervised Learning(비 지도 학습)비지도 학습(Unsupervised Learning)은 데이터만 보고 분석하여 특징이 비슷한 데이터끼리 그룹을 지어 주는 것이다. 이것을 군집화(Clustering, 클러스터링) 라고 한다. 비지도 학습은 데이터의 숨겨진 특징(Feature) 이나 분포, 구조를 밝혀내는데 사용된다.비지도 학습은 정답 라벨(Label)이 주어지지 않기 때문에, 예측한 값이 정답에 가까운지 아닌지 확인 할 수 없다. 따라서, 비지도 학습을 사용하는 경우는 유사한 사용자끼리 군집화(Clustering) 할 때 또는 비슷한 특징을 가지는 기사들을 군집화(Clustering) 할 때 등에 사용 될 수 있다. https://www.mailman.columbia.edu/research/population-health-methods/cluster-analysis-using-k-means   Reference  CS231n 강의 자료 : http://cs231n.github.io/classification/  https://www.mailman.columbia.edu/research/population-health-methods/cluster-analysis-using-k-means  모두를 위한 머신러닝 / 딥러닝 : https://hunkim.github.io/ml/  솔라리스의 인공지능 연구실 : http://solarisailab.com/archives/1785  http://mangkyu.tistory.com/32",
        "url": "//data%20science/machine%20learning/2018/04/13/ml-1.html"
      }
      ,
    
      "android-android-2018-01-19-android-6-html": {
        "title": "안드로이드 프로그래밍(Android Programming) - 로그인(Login) 폼에 스크롤 뷰 적용",
        "tags": "Android",
        "date": "January 19, 2018",
        "author": "",
        "category": "",
        "content": "기존에 작성한 [로그인폼 만들기](https://devyurim.github.io/2018/01/17/8.html) 에서는 입력을 위해 키보드를 띄웠을때 버튼이 가려지는 단점이 있었다. 따라서 ScrollView를 적용하여 이런 단점을 보완하였다.  1. activity_login.xml 파일 수정일단 res -&gt; layout -&gt; activity_login.xml 파일에서 아래의 레이아웃 구조처럼 수정하였다.스크롤 뷰(ScrollView)에 관한 기본적인 attribute를 보면 다음과 같다.      scrollbarStyle    안드로이드에서 지원하는 스크롤바 스타일에는 4가지가 존재한다.              스타일      기능                  insideOverlay      Padding 추가 없이 내용물의 안쪽에 스크롤바를 배치한다.  스크롤 바가 내용물 위에 투명하게 올라간다.              insideInset      Padding을 추가하고 패딩영역에 스크롤바를 배치한다.  스크롤 바가 내용물에 오버랩되지 않는다.              outsideOverlay      Padding 추가 없이 스크롤바를 화면 가장자리에 배치한다.  스크롤 바가 내용물 위에 투명하게 올라간다.              outsideInset      Padding을 추가하고 스크롤바를 화면 가장자리에 배치한다.  스크롤 바가 내용물에 오버랩되지 않는다.      원하는 스크롤바 스타일을 골라서 설정해 주면 된다. 나는 OutsideOverlay를 사용하였다.       style  스크롤바 스타일도 여러종류를 선택 할 수 있다. 선택지는 다음과 같다. 지금 현재 필요한 기능은 아닌거 같아서 default로 사용하였다.      fillViewport  fillViewport 항목은 True일 때 내용물의 크기가 화면을 넘어가도 알아서 내용물의 크기만큼 뷰가 확장이 된다. False이면 내용물의 크기가 화면밖으로 넘어가도 보이지 않게 된다. 따라서 스크롤 뷰 fillViewport 적용시 스크롤 뷰의 height는 자식 뷰에 있는 콘텐츠 길이에 따라 결정되 기 때문에 자식뷰의 match_parent의 속성은 적용될 수 없다.       clipToPadding  clipToPadding은 스크롤의 오작동 없이 뷰( scrollView, listView, gridView )에 padding 값을 주고 싶을 때 조절할 수 있는 항목이다.( 디폴트 값은 True이다 ) 패딩을 주는 이유는 뷰의 맨 마지막 요소가 다른 뷰에 오버랩 되어 가려지기 때문인데 해당 뷰에 패딩을 주게 되면 스크롤이 패딩이 적용된 안쪽에서만 작동하는 오류가 생기게 된다. 그렇기 때문에 해당 뷰 위아래에 header 와 footer를 추가하는 방법도 있지만 clipToPadding 항목을 False로 사용하면 쉽게 해결된다.이제 키보드가 올라와도 양식이 자동으로 위로 밀려서 버튼이 겹치지 않는다!",
        "url": "//android/android/2018/01/19/android-6.html"
      }
      ,
    
      "android-android-2018-01-17-android-5-html": {
        "title": "안드로이드 프로그래밍(Android Programming) - 로그인(Login) 폼 만들기",
        "tags": "Android",
        "date": "January 17, 2018",
        "author": "",
        "category": "",
        "content": "  1. 로그인 액티비티 생성안드로이드에서 기본적으로 로그인 폼을 지원한다. Activity 추가시 Login Activity 를 생성한다.Activity Name과 레이아웃 xml 파일 이름, 타이틀 이름을 입력하고 Finish 버튼을 눌러서 생성한다.  2. 레이아웃 구조 수정res-&gt; layout -&gt; activity_login.xml 파일을 보면 현재 페이지의 레이아웃이 어떻게 구성되어지는지 볼 수 있다. 여기서 필요한 요소를 추가하거나 삭제할 수 있다. Component Tree 탭을 활용하면 현재 레이아웃 계층이 어떻게 구성되어 있는지 한눈에 알아 볼 수 있다. 로그인 폼이 어떻게 만들어 졌는지 살펴 보면 Linear Layout(Horizontal) -&gt; Scroll View -&gt; Linear Layout(Vertical) 안에 EditText, Button 등이 차례로 들어가져 있는 모습을 볼 수 있다. Scroll View는 필요 없을 것 같아 삭제하고 구조를 Linear Layout(Horizontal) -&gt; LinearLayout(Vertical) -&gt; EditText, EditText, Button, Button 구조로 수정하였다. 안드로이드 어플리케이션의 화면을 구성할 때 버튼이나 텍스트 뷰, 텍스트입력, 버튼 등 각 요소를 넣으려면 Layout 안에 넣어줘야 어느 화면에서나 구조적으로 배치가 될 수 있다. 여기서는 LinearLayout이 Layout 컴포넌트에 해당이 된다. Layout 구조는 아래의 그림과 같이 다양하게 구성되어 있다. 구현시 원하는 기능대로 레이아웃을 추가하여 레이아웃 안에 컴포넌트를 추가하면 된다.res-&gt; layout -&gt; activity_login.xml 파일을 보면 레이아웃 구조를 Text로 변경해서 보면 각 요소별로 설정을 할 수 있다. id는 해당 컴포넌트를 구별하기 위하여 이름을 지어두는 곳이고, layout_width, layout_height 는 해당 컴포넌트의 가로, 세로 길이를 결정한다. match_parent 는 쉽게 말하면 부모 컴포넌트의 가로나 세로 길이에 맞춰서 해당 컴포넌트의 길이를 설정하라는 뜻이다. 레이아웃 뷰에서 Linear Layout의 가로 길이를 화면의 가로 길이만큼(match_parent)으로 설정 했기 때문에 button의 width(가로)를 match_parent로 설정했을때 가로 길이가 화면에 꽉차게 보이는 것이다.wrap_content 는 해당 뷰에 들어있는 내용물의 크기에 따라 뷰의 크기가 결정되도록 조정한다. 즉, 컴포넌트에 텍스트가 존재하면 텍스트의 크기 만큼 컴포넌트의 크기가 결정되는 것이다. margin 은 컴포넌트와 컴포넌트 사이의 간격(바깥 여백)을 지정하는 것이고, padding 은 컴포넌트에 할당된 뷰 내부(안쪽 여백)에서 크기를 조절 할 때 사용한다. 아래의 로그인과 회원가입 버튼처럼 버튼을 한 행에 배치 할 때는 LinearLayout(horizontal)을 추가한 뒤 버튼 2개를 레이아웃 안에 추가해주면된다. 버튼의 길이를 결정할 때 임의의 값을 지정해주게 되면 화면 크기에 따라서 다르게 보이기때문에 weight 라는 속성을 이용하여 지정하였다. 로그인 버튼과 회원가입 버튼의 weight를 1 로 지정했기 때문에 한 행에서 동일한 길이의 버튼이 생성되었다. 만약, 로그인 버튼의 weight를 2, 회원가입 버튼의 weight를 1로 지정하였다면 로그인의 버튼이 회원가입 버튼보다 상대적으로 길이가 길 것이다. (weight 2는 전체 길이의 2/3, weight 1은 전체 길이의 1/3)  weight가 1:1 인 경우  weight가 2:1 인 경우수정한 폼과 코드는 아래와 같다.  activity_login.xml&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:tools=\"http://schemas.android.com/tools\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\"    android:gravity=\"center_horizontal\"    android:paddingBottom=\"@dimen/activity_vertical_margin\"    android:paddingLeft=\"@dimen/activity_horizontal_margin\"    android:paddingRight=\"@dimen/activity_horizontal_margin\"    android:paddingTop=\"@dimen/activity_vertical_margin\"    tools:context=\"com.example.devyurim.orangeaid.LoginActivity\"&gt;    &lt;LinearLayout        android:id=\"@+id/email_login_form\"        android:layout_width=\"match_parent\"        android:layout_height=\"match_parent\"        android:gravity=\"center\"        android:orientation=\"vertical\"&gt;        &lt;EditText            android:id=\"@+id/email\"            android:layout_width=\"match_parent\"            android:layout_height=\"wrap_content\"            android:hint=\"@string/prompt_email\"            android:inputType=\"textEmailAddress\"            android:maxLines=\"1\"            android:singleLine=\"true\" /&gt;        &lt;EditText            android:id=\"@+id/password\"            android:layout_width=\"match_parent\"            android:layout_height=\"wrap_content\"            android:hint=\"@string/prompt_password\"            android:imeActionId=\"6\"            android:imeActionLabel=\"@string/action_sign_in\"            android:imeOptions=\"actionUnspecified\"            android:inputType=\"textPassword\"            android:maxLines=\"1\"            android:singleLine=\"true\" /&gt;        &lt;LinearLayout            android:layout_width=\"match_parent\"            android:layout_height=\"wrap_content\"            android:orientation=\"horizontal\"&gt;            &lt;Button                android:id=\"@+id/email_sign_in_button\"                style=\"?android:textAppearanceSmall\"                android:layout_width=\"wrap_content\"                android:layout_height=\"wrap_content\"                android:layout_marginTop=\"16dp\"                android:layout_weight=\"1\"                android:text=\"@string/action_sign_in\"                android:textStyle=\"bold\" /&gt;            &lt;Button                android:id=\"@+id/email_sign_up_button\"                style=\"?android:textAppearanceSmall\"                android:layout_width=\"wrap_content\"                android:layout_height=\"wrap_content\"                android:layout_marginTop=\"16dp\"                android:layout_weight=\"1\"                android:text=\"@string/action_sign_up\"                android:textStyle=\"bold\" /&gt;        &lt;/LinearLayout&gt;    &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;  3. 컴포넌트 텍스트 수정res -&gt; values -&gt;strings.xml 파일에 가보면 로그인 폼에서 사용되는 string 변수들이 자동으로 생성되어 있다. 여기서 원하는 텍스트로 수정해주면 된다.(text view 글자, hint 글자, button 글자, page title 등)추가 문구가 필요하면 생성하고 컴포넌트에 매칭시켜주면 된다. 필요한 사항만 남기고 나머지는 모두 지웠다. 필요 할때마다 추가하여 사용한다.layout_login.xml에 가보면 text 요소에 “@string/action_sign_in”라고 기재되어 있다. 이 코드의 의미는 strings.xml의 name이 action_sign_in인 문구를 사용하라는 뜻이다. 통일성을 위해서 나는 strings.xml 파일을 사용하여 텍스트 값을 변경하였다.추가적으로 화면의 타이틀을 변경하고 싶으면 AndroidManifest.xml 파일에서 해당 액티비티의 label 값을 수정해주면 된다.   4. LonginActivity.java 수정로그인 액티비티를 생성하면 로그인 기능에 사용되는 기본적인 함수들이 자동으로 생성이 되므로 나중에 기능을 추가할 때 문서를 보고 함수를 수정하면 된다. 아직 서버가 완성되지 않았으므로 일단은 onCreate 함수 빼고 모두 지워 주었다. 필요한 기능이 생길때 마다 그때 함수를 추가하는 방식으로 작성할 예정이다.또한, EditText나 Button에서 각각 이벤트 핸들러를 적용할 수 있도록 이벤트 핸들러 함수를 추가하였다. 또한, 이메일 입력 자동완성기능은 DB와 연동이 필요하기 때문에 AutocompleteTextView에서 textedit로 컴포넌트를 변경해 주었다.수정한 코드는 아래와 같다.  LoginActivity.javaimport android.app.Activity;import android.os.Bundle;import android.view.KeyEvent;import android.view.View;import android.view.View.OnClickListener;import android.view.inputmethod.EditorInfo;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;public class LoginActivity extends Activity {    // UI references.    private EditText mEmailView;    private EditText mPasswordView;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_login);        // Set up the login form.        mEmailView = (EditText) findViewById(R.id.email);        mPasswordView = (EditText) findViewById(R.id.password);        // event handler        mEmailView.setOnEditorActionListener(new TextView.OnEditorActionListener()        {            @Override            public boolean onEditorAction(TextView textView, int id, KeyEvent keyEvent) {                if(id == EditorInfo.IME_ACTION_DONE || id == EditorInfo.IME_NULL){                   return true;                }                return false;            }        });        mPasswordView.setOnEditorActionListener(new TextView.OnEditorActionListener() {            @Override            public boolean onEditorAction(TextView textView, int id, KeyEvent keyEvent) {                if (id == EditorInfo.IME_ACTION_DONE || id == EditorInfo.IME_NULL) {                    //attemptLogin();                    return true;                }                return false;            }        });        // Button        Button mEmailSignInButton = (Button) findViewById(R.id.email_sign_in_button); // sign in button        Button mEmailSignUpButton = (Button) findViewById(R.id.email_sign_up_button); // sign up button        // event handler        mEmailSignInButton.setOnClickListener(new OnClickListener() {            @Override            public void onClick(View view) {            }        });        mEmailSignUpButton.setOnClickListener(new OnClickListener(){            @Override            public void onClick(View view) {            }        });    }}아직 서버가 연동되지 않았으므로 각 버튼을 눌렀을 시 다른 액티비티로 넘어가도록 구현 하였다. 로그인 버튼을 눌렀을 때 MainActivity 로 넘어가고 회원가입 버튼을 눌렀을때 RegisterActivity 로 넘어가도록 핸들러를 구현하였다. 일단 RegisterActivity를 Empty Activity로 추가 해준다음 다음과 같이 코드를 수정하였다.// sign-in button event handler        mEmailSignInButton.setOnClickListener(new OnClickListener() {            @Override            public void onClick(View view) {                Intent intent = new Intent(getApplicationContext(), MainActivity.class);                startActivity(intent);                finish();            }        });        // sign-up button event handler        mEmailSignUpButton.setOnClickListener(new OnClickListener(){            @Override            public void onClick(View view) {                Intent intent = new Intent(getApplicationContext(), RegisterActivity.class);                startActivity(intent);                finish();            }        });추후 웹 서버 연동과 db연동을 한 후 로그인 확인기능과 추가 핸들러 기능을 구현할 예정이다.위의 예제 코드로 왠만한 기본적인 안드로이드 페이지를 응용하여 만들수 있다.(회원가입 폼, 기본 메뉴 화면 등) 어플리케이션에 필요한 화면들을 다 만든 뒤 추가 기능을 추가해야겠다.",
        "url": "//android/android/2018/01/17/android-5.html"
      }
      ,
    
      "android-android-2018-01-17-android-4-html": {
        "title": "안드로이드 프로그래밍(Android Programming) - 시작(Intro) 화면 만들기",
        "tags": "Android",
        "date": "January 17, 2018",
        "author": "",
        "category": "",
        "content": "  1. JavaClass 생성일단 시작 화면을 따로 생성하기 위하여 자바 클래스(java 파일) 를 먼저 생성한다. 클래스 이름은 IntroActivity 하였다.import android.app.Activity;import android.content.Intent;import android.os.Bundle;public class IntroActivity extends Activity{    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        try {            Thread.sleep(4000); // 4초 인트로 화면 보여주기        } catch (InterruptedException e) {            e.printStackTrace();        }        // next Activity 기재.        startActivity(new Intent(this,MainActivity.class));        finish();    }}  2. drawable 폴더에 background_intro.xml 파일 생성&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;    &lt;!-- Background color --&gt;    &lt;item android:drawable=\"@color/windowBackground\"/&gt;    &lt;!-- logo --&gt;    &lt;item&gt;        &lt;bitmap            android:gravity=\"center\"            android:src=\"@mipmap/ic_launcher\"/&gt;    &lt;/item&gt;&lt;/layer-list&gt;  3. vaules/styles.xml 파일 수정아래의 코드를 res -&gt; values -&gt; styles.xml 파일에 스타일을 추가해준다.&lt;!-- intro theme. --&gt;    &lt;style name=\"IntroTheme\" parent=\"Theme.AppCompat.NoActionBar\"&gt;        &lt;item name=\"android:windowBackground\"&gt;@drawable/background_intro&lt;/item&gt;    &lt;/style&gt;  4. AndroidManifest.xml 파일 수정 시작 화면이 현재 MainActivity로 되어 있는데 이를 IntroActivity로 조정하기 위한 작업이다. manifests -&gt; AndroidManifest.xml 파일에 가서 아래와 같이 코드를 수정한다.Intro Theme을 따로 설정 해주는 것을 까먹으면 안된다! 시작 액티비티를 수정하고 반드시 그다음에 실행할 액티비티를 아래에 추가해 주어야 한다. 아래 이미지는 시작 화면 적용한 화면이다.",
        "url": "//android/android/2018/01/17/android-4.html"
      }
      ,
    
      "android-android-2018-01-17-android-3-html": {
        "title": "안드로이드 프로그래밍(Android Programming) - 디자이너 없이 앱디자인 하는 법",
        "tags": "Android",
        "date": "January 17, 2018",
        "author": "",
        "category": "",
        "content": "나는 디자이너가 아니라 개발자 이기 때문에 적당한 UI를 디자인 할 수 있는 방법을 리서치 해 보았다. 리서치 해보니 다양한 가이드라인들이 존재하였고 쉽게 적용할 수 있는 몇 가지 방법을 정리해 보았다.  1. Material Design디자이너가 없는 개발 환경에서 어플을 디자인 할 수 있는 가이드 라인이 존재 한다. 구글에서 제공하는 [Material Guide](https://developer.android.com/training/material/get-started.html?hl=ko) 를 사용하면 된다.   material guide blog : http://davidhyk.github.io/google-design-ko/material-design/introduction.html#introduction-principles구글에서 제공하는 Material Guide 를 사용하면 이미지 파일을 포토샵으로 소스를 만들어 추출 할 필요 없이 안드로이드 디자인 서포트 라이브러리를 연결함으로써 가이드된 UI를 사용 할 수 있다. 여백이나 사이즈 등 수치만 잡아주면 되므로 매우 심플하고 편리하게 어플리케이션을 개발 할 수 있다. Material Design은 안드로이드 API 21(롤리팝) 이상 에서만 사용할 수 있다. 안드로이드 스튜디오에서 API 21 이상을 선택하게 되면 테마는 자동으로 머티리얼 테마가 적용이 된다. 머티리얼 테마가 적용이 된것을 확인하려면 res -&gt; values -&gt; sytle.xml 에서 아래의 사진과 같다면 적용이 된 것이다.머티리얼 테마는 style.xml 에서 다음과 같이 적용 될 수 있다.  android:style/Theme.Material (어두운 버전)  android:style/Theme.Material.Light (밝은 버전)  android:style/Theme.Material.Light.DarkActionBar사용가능 한 머리티얼 스타일 목록은 [R.style](https://developer.android.com/reference/android/R.style.html?hl=ko) 에서 확인 할 수 있다.    2. Theme Color 지정하기Material Theme를 상속 시 테마의 기본 색상을 변경 할 수 있다. 사용자 지정 색상을 사용할 수 있다. 먼저 사용자 색상을 설정하기 위한 요소들은 다음 아래의 그림과 같다.color 값은 res -&gt; values -&gt; colors.xml 에서 지정 할 수 있다. 디자이너 없이 좋은 컬러값을 추출해 내는 것이 어려운데 [Material Palette](https://www.materialpalette.com/) 를 사용하면 쉽게 컬러 값을 추출 할 수 있다. 각 색상값을 더블클릭하면 웹 컬러값을 자동으로 클립보드에 복사해주기 때문에 ctrl + v하여 사용하거나 palettes 탭에서 주요 테마 색상 2가지를 선택하면 자동으로 테마 뷰를 보여준다.color 값 정보는 res -&gt; values -&gt; color.xml 파일에 기재하고 컬러값 설정은 res -&gt; values -&gt; styles.xml 에서 설정한다.   res -&gt; values -&gt; colors.xml&lt;resources&gt;    &lt;color name=\"colorPrimary\"&gt;#FF9800&lt;/color&gt;    &lt;color name=\"colorPrimaryDark\"&gt;#F57C00&lt;/color&gt;    &lt;color name=\"windowBackground\"&gt;#ffffff&lt;/color&gt;    &lt;color name=\"textColorPrimary\"&gt;#ffffff&lt;/color&gt;    &lt;color name=\"textColor\"&gt;#212121&lt;/color&gt;    &lt;color name=\"colorAccent\"&gt;#FF5722&lt;/color&gt;&lt;/resources&gt;  res -&gt; values -&gt; styles.xml&lt;resources&gt;    &lt;!-- Base application theme. --&gt;    &lt;style name=\"AppTheme\" parent=\"android:Theme.Material.Light\"&gt;        &lt;!-- Customize your theme here. --&gt;        &lt;item name=\"android:colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt;        &lt;item name=\"android:colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt;        &lt;item name=\"android:textColorPrimary\"&gt;@color/textColorPrimary&lt;/item&gt;        &lt;item name=\"android:colorAccent\"&gt;@color/colorAccent&lt;/item&gt;    &lt;/style&gt;&lt;/resources&gt;  3. Material Icon 사용하기아이콘은 구글이 공개한 저작권 없는 [Material Icon](https://material.io/icons/) 을 사용하면 된다. Meterial Icon 홈페이지에 접속하면 아이콘을 선택하여 dp별로 SVG(벡터파일)이나 PNG 파일로 다운 받을 수 있다.  refernece  https://developer.android.com/training/material/get-started.html?hl=ko  http://davidhyk.github.io/google-design-ko/material-design/introduction.html#introduction-principles",
        "url": "//android/android/2018/01/17/android-3.html"
      }
      ,
    
      "android-android-2018-01-03-android-2-html": {
        "title": "안드로이드 프로그래밍(Android Programming) - 프로젝트 생성하기(hello project!)",
        "tags": "Android",
        "date": "January 3, 2018",
        "author": "",
        "category": "",
        "content": "안드로이드 어플을 제작하기 위해서는 프로젝트를 생성해야한다. Start a new Android Studio Project를 클릭하여 프로젝트를 생성한다.Application name은 어플의 이름을 지정하는 부분이다. 기기에 설치 및 실행되는 앱의 이름으로 사용이 된다.Company Domain은 개발자를 식별할 수 있는 이름을 도메인 형식으로 입력하는 곳이다.Project location은 프로젝트를 설치할 경로(저장 될 경로)를 입력하는 곳이다. […] 버튼을 눌러서 경로를 변경할 수 있다. 간단한 설정을 하고 Next 버튼을 클릭한다.어플이 실행될 API 버전을 결정한다. API 버전은 어플이 실행될 최소의 안드로이드 버전을 말한다. 버전이 낮을 수록 많은 기기에서 호환이 가능하다.왼쪽의 그래프를 보면 안드로버전 대비 몇프로 정도 지원이 되는지 가이드라인이 있다. 버전이 낮을 수록 모든 기기에서 지원되지만 고려해야할 사항이 많아진다고 한다. 나는 KiKat(4.4)로 결정하였다.그다음은 액티비티(Activity) 종류를 결정하는 단계이다. 액티비티(Activity) 는 일종의 어플리케이션 구성요소로서 사용자가 전화걸기, 사진찍기, 이메일 보내기 또는 지도 보기 등의 일을 하기 위해서 상호작용할 수 있는 화면을 제공하는 곳이다. 하나의 어플리케이션은 여러개의 액티비티가 느슨하게 서로 묶여 있는 형태로 구성이 된다. 한 어플리케이션 내에서 하나의 액티비티가 주요 액티비티로 지정되며, 사용자가 이 어플리케이션을 처음 실행 할 때 엑티비티가 사용자에게 표시된다.원하는 액티비티(Activity)의 형식을 고르고 Next버튼을 클릭한다. 나는 Emtpy Activity를 선택하였다.그 다음 화면은 Activity name과 Layout name을 결정하는 화면이다. Activity name으로 이루어진 java파일이 생성되고 Layout name 으로 이루어진 Layout 리소스들, 레이아웃 구조 등이 담긴 xml 파일이 생성된다.또한, 하단에 보면 Backwards Compatibility(AppCompat) 라는 옵션이 있는데 이 옵션은 액티비티를 AppCompactActivity로 만들겠다는 의미이다. AppCompactActivity는 안드로이드 하위버전을 지원하는 액티비티이다. Activity API level을 확인하면 API level 11(안드로이드 3.0)이라고 적혀있다. 즉, 어플을 몇버전부터 지원할지 결정한다음에 AppCompactActivity 옵션을 결정하면 된다. 나는 KiKat(4.4) 부터 지원할 거기 때문에 그냥 옵션체크를 해제하였다. 이름을 결정하고 Finish 버튼을 클릭한다.java 폴더에보면 액티비티 이름으로 생성된 자바파일이 생성된 것을 볼 수 있다. res는 어플의 레이아웃, 이미지 리소스 등 어플리케이션에 사용되는 리소스들을 집어넣는 곳이다.res -&gt; layout -&gt; activity_main.xml 을 클릭하면 어플 화면의 레이아웃을 쉽게 변경할 수 있다.일단 어플리케이션을 build &amp; run 하기 위해서 상단의 플레이 표시를 클릭하여 실행한다. 실행하게 되면 에뮬레이터를 실행할 수 있는 화면이 나온다. 만약 에뮬레이터를 설치하지 않았다면 Create New Virtual Device 버튼을 클릭하여 에뮬레이터를 만든 후 실행하면 된다. 에뮬레이터 설치시 원하는 사이즈의 기종을 선택하여 테스트용으로 설치하면 된다. 에뮬레이터를 다 설치하였다면 에뮬레이터를 선택하고 ok버튼을 눌러 실행을 계속 진행하면 된다.이렇게 화면에 잘 뜬다면 잘 만든 것이다!",
        "url": "//android/android/2018/01/03/android-2.html"
      }
      ,
    
      "android-android-2018-01-03-android-1-html": {
        "title": "안드로이드 프로그래밍(Android Programming) 시작하기",
        "tags": "Android",
        "date": "January 3, 2018",
        "author": "",
        "category": "",
        "content": "&lt;p&gt;연구실에서 이번년도 산학연 과제로 하드웨어-안드로이드어플-서버구축 부분을 개발하게 되었다. 일단 첫 공부로 안드로이드 프로그래밍부터 공부하기로 결정하였다! 일단 이번 방학까지 구현해야 하는 어플에 대해서 1차적인 개발은 마칠 예정이다. 서버 부분은 나 혼자 하는 작업은 아니지만 다른 사람들과의 협업을 위해 일단 조금씩 골고루 공부해 두는것으로…!&lt;/p&gt;안드로이드 프로그래밍은 3학년 1학기 때 경진대회에 참가하면서 약간 다뤄본 경험이 있다. 그때 스크랩한 내용들이랑 새로 스크랩한 내용들을 정리해서 포스팅을 작성할 예정이다. 안드로이드 프로그래밍에 대한 자료들은 구글에도 아주 방대하게 있고 MOOC강의나 책을 사면 무료 공개되는 강의들이 많으니 골고루 참고할 예정이다.  1. JAVA JDK 설치일단 안드로이드 프로그래밍 개발은 자바(Java)언어를 기반으로 이루어진다. 안드로이드 프로그래밍을 하기 위해서는 우선 JAVA JDK(Java Development Kit) 가 반드시 설치 되어 있어야 한다. 아래의 링크를 타고 들어가서 운영체제에 맞는 JDK를 설치하면 된다.  Java JDK : http://www.oracle.com/technetwork/java/javase/downloads/jdk9-downloads-3848520.html  1-1. 윈도우(Windows) 설정JDK를 설치하고 난 후 자바 환경변수(JAVA_HOME, PATH)를 설정해 주어야 JDK를 사용할 수 있다. 윈도우는 환경변수 설정에 가서 두가지 작업을 해야한다.  사용자 변수 새로 만들기          변수 이름 : JAVA_HOME      변수 값 : jdk가 설치 된 경로 (ex. “C:\\Program Files\\Java\\jdk.1.8.0_25”)        변수 PATH에 경로 추가          변수값 맨 뒤에 jdk 경로를 추가해준다.(ex. C:\\Program Files\\Java\\jdk.1.8.0_25;)      cmd 창을 켜고 java-version 을 쳐서 버전이 올바르게 나오면 제대로 경로가 설정이 된것이다.  1-2. 맥 OS(Mac OS), 리눅스(Linux) 설정맥은 명령어로 자바 환경변수 설정이 가능하다.1) JAVA 디렉토리로 이동$ cd /Library/Java/JavaVirtualMachines2) ls 명령어를 이용하여 jdk 버전 확인 -&gt; 메모 해둔다!3) home 파일로 접속/*위에서 메모한 jdk버전 사용*/$ cd /Library/Java/JavaVirtualMachines/jdk.1.8.0_25.jdk/Contents/Home4) vim 에디터를 이용하여 bash_profile 접근$ vi ~/.bash_profile5) 수정모드에서 경로 추가/*위에서 메모한 jdk버전 사용*/export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk.1.8.0_25.jdk/Contents/Homeesc 누른 후, :wq로 저장하고 모드를 빠져나온다.6) 터미널에서 자바 버전 확인$ java-version이렇게 셋팅을 완료하면 자바를 사용하기 위한 환경 설정은 완료된다.   2. 통합개발환경(IDE) 설치이제 본격적으로 안드로이드 프로그래밍을 하기 위한 IDE를 설치할 차례이다. 통합개발환경(IDE)으로는 안드로이드 스튜디오(Android Studio) 또는 이클립스(Eclipse) 를 이용하여 개발을 할 수 있다.안드로이드 스튜디오는 Jetbrain 회사의 Intellij와 거의 비슷하다. 또한, 에뮬레이터를 지원한다. 에뮬레이터는 간단하게 말하면 만든 소스의 기능을 테스트 할 수 있는 가상 기기이다. 굳이 안드로이드 휴대폰에 어플을 집어넣지 않아도 테스트가 가능하다는 장점이 있다. 다만, 에뮬레이터 기능 때문에 프로그램이 조금 무겁다고 느껴진다. 맥북 프로에서 안드로이드 스튜디오를 돌렸을 때 메모리가 16기가인데 에뮬레이터 돌릴때 약간 무겁다는 느낌이 많이 들었다.이클립스는 안드로이드 스튜디오보다는 가벼운 편이다. 자바를 개발하면서 이클립스 단축키나 사용법에 익숙한 사람들은 이클립스를 사용한다고 들었다. 자신에게 편한 IDE를 사용하면 된다. 둘중에 하나 자신이 원하는 통합개발환경을 설치하면 된다.나는 Jetbrain 회사의 프로그램들을 무료 학생계정으로 자주 사용하여 안드로이드 스튜디오를 쓰기로 결정하였다. 개발환경은 MAC OS X Android Studio로 공부를 진행 할 예정이다.",
        "url": "//android/android/2018/01/03/android-1.html"
      }
      ,
    
      "development-20environment-github-20blog-2018-01-01-blog-5-html": {
        "title": "지킬(Jekyll) 블로그에 구글 웹폰트 적용하기",
        "tags": "Github Blog",
        "date": "January 1, 2018",
        "author": "",
        "category": "",
        "content": "간단하게 웹폰트 수정하는 법을 정리하고자 포스팅을 하였다.구글 에서 무료로 웹폰트를 제공하는데 이를 github 블로그에서 적용할 수 있다. 적용가능한 폰트 리스트는 링크된 사이트를 참조하면 좋을 것 같다. 나는 블로그의 폰트를 나눔 고딕으로 변경하였다. 변경 기준은 현재 블로그에 사용하고 있는 Type Theme을 기준으로 작성하였다.구글 font 사이트에서 나눔고딕 웹폰트 설정하는 법을 찾아보았다. 다음과 같이 셋팅해주면 된다고 한다.  1. _config.yml 파일 변경_config.yml 파일에서 google_fonts의 값을 아래와 같이 변경 하였다.  2. font-family 이름 변경_sass -&gt; base -&gt; _variables.scss 파일에서 font-family를 다음과 같이 변경한다. font-family-main은 본문의 font 설정이고, font-family-headings는 타이틀의 font 설정이다.이렇게 두가지만 적용하고 각 파일을 저장해서 다시 github에 push하면 적용 완료이다!  reference  http://makebct.net/%EA%B5%AC%EA%B8%80%EC%9B%B9%ED%8F%B0%ED%8A%B8-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0/?cat=148/  https://fonts.google.com/specimen/Nanum+Gothic?selection.family=Nanum+Gothic:400,700",
        "url": "//development%20environment/github%20blog/2018/01/01/blog-5.html"
      }
      ,
    
      "development-20environment-github-20blog-2018-01-01-blog-4-html": {
        "title": "지킬(Jekyll) 설치하기 - Windows 10",
        "tags": "Github Blog",
        "date": "January 1, 2018",
        "author": "",
        "category": "",
        "content": "요즘 노트북은 잘 안쓰고 연구실 컴퓨터로 거의 작업을 하고 있다! 연구실 컴퓨터에는 지킬(jekyll)이 깔려있지 않으니 뭔가 포스팅을 안하는 느낌이여서 시험도 끝났겠다 지킬을 설치하였다! 약간의 삽질이 있었으므로 설치 방법을 글로 남기려고 한다ㅠ.ㅠ연구실 컴퓨터는 Windows 10 pro 버전이다.   1. 루비(ruby) 설치 윈도우 컴퓨터에는 맥 OS 같이 루비가 깔려있지 않으므로 루비를 설치해주어야 한다! 다운로드는 아래의 사이트에서 할 수 있다.  ruby 다운로드 : https://rubyinstaller.org/downloads/ Devkit 을 같이 설치한다! 나는 안정 버전이라고 표시된 2.4.4-1 version을 설치하였다.** 만약 Git 이 설치되어 있지 않으면 설치해야한다! **  git 다운로드 : https://git-scm.com/downloads    2. 지킬(jekyll) 설치 설치가 끝나면 윈도우 검색창에 ruby를 치면 ‘Start Command Prompt with Ruby’ 라는 Command 창을 킨다. 다음의 명령어를 통해 지킬을 설치한다.gem install jekyll   3. 블로그 페이지에 bunlde 설치하기 이 경우는 블로그 페이지가 이미 있는 경우에 한하여 재 설치 할 수 있는 방법이다!만약, 블로그 페이지가 없는 새로운 사용자라면 새로운 저장소(repository)를 만들고 맘에드는 블로그를 clone하여 사용해야 한다.자세한 사항은 이곳 을 참조 하는 것이 좋을 것 같다.나는 블로그를 Dropbox를 통하여 관리하기 때문에 Dropbox 폴더안에 Git에 올려놓은 로컬 파일들이 모두 존재한다.  내 블로그 파일 들이 있는 로컬 경로로 변경하여 접속한다.(C:\\내 로컬파일 경로)  폴더 내에 있는 Gemfile을 이용해서 bundle 설치를 한다.bundle install  jekyll이 되는지 확인하기 위해서 build하고 로컬 실행해 본다.jekyll buildjekyll serve  http://localhost:4000 으로 접속하여 실행이 제대로 되면 윈도우 셋업은 끝이다.만약 블로그를 포스팅하고 최초로 git을 실행하는 것이라면 아래와 같이 git을 셋팅 해준다.git config user.name 계정이름git config user.email 계정이메일포스팅을을 다 작성하고 커밋 명령어를 작성하였는데 커밋(commit)이 되지 않는다면 위와 같이 git유저 정보를 추가 해주면 된다.이렇게 해서 연구실 컴퓨터에도 지킬 설정 끝! 이제 열심히 포스팅 할 일만 남았다 ㅎㅎ",
        "url": "//development%20environment/github%20blog/2018/01/01/blog-4.html"
      }
      ,
    
      "development-20environment-github-20blog-2018-01-01-blog-3-html": {
        "title": "마크다운(Markdown) 문법 정리",
        "tags": "Github Blog",
        "date": "January 1, 2018",
        "author": "",
        "category": "",
        "content": "이번 포스팅은 github 블로그 내용을 원활하게 작성하기 위해서 마크다운(markdown) 문법을 정리해 두려고 작성하였다.  1. 헤더(Header)헤더 크기는 1~6까지 지원한다.# This is H1        ## This is H2### This is H3#### This is H4##### This is H5###### This is H6This is H1This is H2This is H3This is H4This is H5This is H6  2. 인용구인용구는 &gt;를 이용한다. 인용구 안에서 다른 마크업 요소를 섞어서 사용할 수 있다.&gt; 안녕&gt; &gt; 안녕&gt; &gt; * 안녕&gt; &gt; &gt; * 안녕  안녕      안녕          안녕                              안녕                                3. 목록  순서가 있는 목록  1. 일번  2. 이번  3. 삼번  일번  이번  삼번  순서가 없는 목록* 일번  * 이번    * 삼번+ 일번  + 이번    + 삼번- 일번  - 이번    - 삼번  일번          이번                  삼번                      일번          이번                  삼번                      일번          이번                  삼번                      4. 코드&lt; pre &gt; &lt; code &gt; 에 감싸서 사용한다.&lt;code&gt;Github&lt;/code&gt;Github  &lt;pre&gt;&lt;code&gt;  for i in range(1,2):    print(i)  &lt;/code&gt;&lt;/pre&gt;for i in range(1,2):  print(i)ps. 코드 하이라이터를 사용하는 경우(내 지킬 블로그 테마) js 대신에 원하는 언어를 넣을 수 있다. Rouge 하이라이터가 적용 되었다. for i in range(1,2):  print(i)   5. 수평선 ------************   6. 링크   인라인 링크 [Google](http://google.com)Google  자동 연결 링크&lt;http://google.com&gt;http://google.com  8. 강조진하게, 기울기, 취소선이 있다. 밑줄은 지원하지 않는다.*single asterisks*_single underscores_**double asterisks**__double underscores__~~cancelline~~single asteriskssingle underscoresdouble asterisksdouble underscorescancelline  9. 이미지![이미지 이름](이미지 url)로 이미지를 넣을 수 있다.![Image name](https://user-images.githubusercontent.com/20412850/34468412-ba059536-ef4b-11e7-90d4-3313e9fed8f9.png)  ps. 사이즈 조정&lt;img src=\"이미지 url\" width=\"원하는 크기\"&gt;&lt;img src=\"https://user-images.githubusercontent.com/20412850/34468412-ba059536-ef4b-11e7-90d4-3313e9fed8f9.png\" width=\"60%\"&gt;  10. 표 그리기표는 마크다운 표를 generate 해주는 사이트가 있다. 원하는 양식에 맞춰서 만들어서 갖다가 쓰면 편하다.  표 generate 사이트 : https://www.tablesgenerator.com/markdown_tablesFirst Header  | Second Header------------- | -------------Content Cell  | Content CellContent Cell  | Content Cell            First Header      Second Header                  Content Cell      Content Cell              Content Cell      Content Cell      내용 정렬은 아래와 같이 한다.First Header  | Second Header | Third Header:------------ | :-----------: | -----------:Left          | Center        | Right            First Header      Second Header      Third Header                  Left      Center      Right        11. 수식(테마에서 지원)$$ f(x) = \\int \\frac{2x^2+4x+6}{x-2} $$",
        "url": "//development%20environment/github%20blog/2018/01/01/blog-3.html"
      }
      ,
    
      "development-20environment-github-20blog-2018-01-01-blog-2-html": {
        "title": "지킬(Jekyll) 깃허브(Github) 블로그에 포스팅하기",
        "tags": "Github Blog",
        "date": "January 1, 2018",
        "author": "",
        "category": "",
        "content": "이번에 블로그 내용은 마크다운(markdown) 문서를 작성하기 위하여 사용하는 에디터, 깃허브 블로그에 포스팅 적용방법 및 페이지 만드는 법을 정리하기 위하여 작성하였다.   1. 마크다운 에디터 마크다운(Markdown) 형식의 문서를 작성하기 위해서는 마크다운 에디터를 사용하는 것이 편하다.나는 아톰(Atom) 에디터로 마크다운 문서를 작성한다. 아톰 에디터는 마크다운 미리보기(Markdown preview) 를 제공하여 포스팅이 어떻게 작성되는지 확인하면서 작성 할 수 있다. 마크다운 편집기는 Atom이 아니더라도 미리보기가 제공되는 편집기를 사용하는 것을 추천한다.[ Atom편집기 미리보기 예시 ]   2. 마크다운 파일 생성 깃허브 블로그 페이지는 마크다운(Markdown) 문서(.md)로 작성 한다.블로그 디렉터리를 확인하면 _posts 라는 폴더가 있는데 이곳이 블로그 포스팅으로 작성한 파일을 넣어두는 부분이다. 제목은 왠만하면 영어 또는 숫자로 적는 것이 좋다. 한글로 작성하게 되면 가끔 인코딩 오류가 발생하여 페이지 로드 오류가 발생했다.블로그 테마별로 날짜를 적는 형식이 조금씩 다른 것 같다. 어떤 테마에는 위의 yml 형식 부분에 적어 두는 곳도 있고 나처럼 문서 제목에 날짜를 달면 자동으로 포스팅한 날짜가 블로그에 적용이 되는 테마도 있는 것 같다. 파일 제목은 포스팅 콘텐츠의 url에 사용이 된다. 먼저 블로그 포스팅 내용을 작성하기 전에 상단의 위의 그림처럼 형식을 먼저 작성한다. layout: post 는 포스팅 내용을 작성한다는 뜻이다. layout: page 이면 새로운 페이지를 생성할 수 있다. title 은 포스팅 하는 컨텐츠의 이름, comments 는 댓글을 달수 있도록 허용할 것인가 여부, tag 는 포스팅에 달 태그를 작성하는 곳이다. 테마의 기능마다 작성할 수 있는 것이 제한되어 있으므로 테마 기능에 따라서 작성하면 된다.위의 사진은 about.md라는 마크다운 형식의 파일을 작성하여 page를 생성 한 모습이다. 페이지를 생성하고 싶으면 루트 디렉토리에 넣어주면 생성이 된다.(devYurim.github.io/about.md)  3. 깃허브(Github) 블로그에 업로드항상 깃허브에 변경사항을 적용할 때는 저장소에 커밋 및 푸쉬를 해주면 된다./*로컬 저장소로 경로 이동 후 아래의 명령어 실행*/$ git add .$ git commit -m \"커밋내용\"$ git push origin master",
        "url": "//development%20environment/github%20blog/2018/01/01/blog-2.html"
      }
      ,
    
      "development-20environment-github-20blog-2018-01-01-blog-1-html": {
        "title": "지킬(Jekyll)을 이용하여 깃허브(Github) 블로그 개설하기",
        "tags": "Github Blog",
        "date": "January 1, 2018",
        "author": "",
        "category": "",
        "content": "이번에 Github로 블로그를 이전하면서 Jekyll 을 이용하여 블로그를 개설 하였다.  원래 Tistory 블로그를 사용하였는데 코드 하이라이팅이나 에디터가 맘에 들지 않아서 옮기기로 결정하였다.또한, 대학교 4학년이고 이제 석사 과정을 준비중인 나에게 뭔가 프로그래머스러운(?) 전문적인 블로그가 필요하다고 생각하였고 활발한 오픈소스 활동을 할 수 있는 곳이 Github 이였다.이번에 블로그를 옮기면서 커스터마이징 하는데 정말 힘들었다…. 2학년때 HTML/CSS 과목을 듣긴했는데 공부좀 열심히 해둘걸 그랬다..ㅎㅎ테마를 다운 받아서 사용했음에도 불구하고 커스터마이징 하는데 꼬박 2일이 걸렸다. 그럼에도 불구하고 Github 블로그를 사용하는 이유 는 내 입맛대로 레이아웃을 짤 수 있어서 좋은 것 같다.Github 블로그 개설은 지킬(Jekyll)이라는 깃허브 페이지에서 지원하는 블로그 정적 생성기를 이용하였다. 가이드 작성은 MAC OS를 기준으로 작성 되었습니다.    1.Git 및 Github 저장소(Repository) 개설 일단 Github 블로그를 개설하려면 Git 이라는 프로그램을 설치하여야 한다. 블로그 관리는 로컬에서 이루어 지며 내 로컬 디렉토리를 Git저장소로 만들기 위하여 Git 이라는 프로그램이 필요하다.  Git 설치 : https://git-scm.com 본인의 Github 계정으로 들어가 자신의 계정 이름으로 저장소를 생성하여야 한다.clone하고 싶은 장소로 터미널의 루트를 이동하여 아래의 명령어로 저장소를 clone을 한다. 자신의 github 저장소 주소를 입력하면 된다.$ git clone https://github.com/devYurim/devYurim.github.io.git   2. 지킬(Jekyll) 설치 블로그를 설치하려면 jekyll 을 설치하여야 한다.루비(ruby)가 없다면 루비를 설치하고 진행하여야 한다. 맥이나 리눅스는 brew를 이용하여 쉽게 설치가 가능하다. 또한, 이미 맥OS에는 루비가 이미 설치되어 있다.만약 windows라면 아래의 링크를 참고하길 바란다.  windows에서 지킬 설치 : https://devyurim.github.io/2018/04/30/11.html루비가 설치되어 있다면 아래의 명령어로 지킬을 설치한다.$ sudo gem install jekyllclone 한 디렉토리 경로로 이동하여 아래의 명령어를 이용해 지킬 블로그를 설치한다. 지킬 블로그 오픈소스 테마를 적용하려면 3. 지킬 테마 설치 참고 하여 셋팅하면 된다. 아래의 과정은 아주아주 기본적인 지킬 블로그를 설치하게 되는 과정이다./*해당 디렉토리에 설치 됨.*/$ jekyll new .블로그를 로컬에서 실행하려면 아래의 명령어를 이용하여 실행할 수 있다.$ jekyll build$ jekyll serve --watch명령어를 실행한 후 http://localhost:4000 으로 접속하면 블로그가 개설이 된 것을 확인 할 수 있다.github에 적용하려면 해당 디렉토리에서 아래와 같이 명령어를 입력하여 저장소에 커밋 및 푸쉬를 하면 된다.$ git add .$ git commit -m \"커밋 내용 입력\"$ git push origin master(자신의 github homepage 주소) https://devYurim.github.io 로 접속하면 블로그가 적용된 것을 볼 수 있다.  3. 지킬 테마(Theme) 설치2번 처럼 설치하면 처음부터 끝까지 모두 블로그를 커스터마이징을 해야한다. 하지만, 미리 만들어진 테마를 이용하면 기존 테마에서 조금만 변경하면 원하는대로 커스터마이징이 가능하다. 아래의 사이트에서 여러가지 테마를 무료로 다운받고 수정하여 사용할 수 있다.  지킬 테마 모음 사이트 : http://jekyllthemes.org원하는 스타일의 테마를 다운 받고 폴더 안에 있는 파일들을 git과 연결된 로컬 디렉토리 안에 넣고 커밋 및 푸쉬를 하면 테마가 내 블로그에 적용이 된다.(github commit 및 로컬 실행 관련해서는 2번 참고)디렉터리 구조를 간략히 살펴보면  includes : 블로그 삽입 html  layouts : 블로그 레이아웃 html  posts : 블로그 컨텐츠들  sass : css 파일들  site : 지킬로 빌드된 블로그 내용들  assets : 이미지파일, js파일, css파일들  config.yml : 블로그 생성에 필요한 config가 적힌 파일들config.yml에 들어가 자신에게 맞게 옵션을 수정하면 된다. 디자인을 변경하고 싶으면 css파일이나 html파일을 수정하면 된다. 내가 적용한 테마는 Type Theme 이다. 지금 사용하고 있는 테마는 반응형 테마에 블로그 디자인도 심플하고 태그 기능, 검색기능, 소셜 플러그인도 잘 지원할 뿐더러 코드 하이라이팅 기능과 수학 수식 작성 기능도 지원하여 매우 만족스럽게 사용중이다!지금 내가 사용하는 테마를 포함해서 몇가지 테마를 더 추천하자면 아래와 같다.  Indigo Minimalist Jekyll Template  Jasper2  Hydeout나는 1번의 Indigo minimalist 테마 디자인이 맘에들어서 현재 적용한 테마에서 디자인 부분만 비슷하게 약간 수정하였다 :)이렇게 자신이 원하는대로 수정이 가능한 점은 좋은 것 같다. 다만 HTML/CSS에 익숙하지 않다면 진입장벽이 높은건 어쩔수 없는것 같다.",
        "url": "//development%20environment/github%20blog/2018/01/01/blog-1.html"
      }
      
    
  };
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/0.7.1/lunr.min.js"></script>
<script src="/assets/js/search.js"></script>
</section>
</article>

    </div>
    
<script src="/assets/js/katex_init.js"></script>



<footer class="site-footer">
	<p class="text">Powered by <a href="https://jekyllrb.com/">Jekyll</a> with <a href="https://github.com/rohanchandra/type-theme">Type Theme</a>
</p>
</footer>


    <script id="dsq-count-scr" src="//.disqus.com/count.js" async></script>

    <!-- Google Analytics Tracking code -->
<script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', '']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script>

  </body>
</html>
